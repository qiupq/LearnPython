<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0038)http://www.swig.org/Doc1.3/Python.html -->
<HTML><HEAD><TITLE>SWIG and Python</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252"><LINK 
href="SWIG and Python_files/style.css" type=text/css rel=stylesheet>
<META content="MSHTML 6.00.2900.2604" name=GENERATOR></HEAD>
<BODY bgColor=#ffffff>
<H1><A name=Python></A>29 SWIG and Python</H1><!-- INDEX -->
<DIV class=sectiontoc>
<UL>
  <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn2">Overview</A> 
  <LI><A 
  href="http://www.swig.org/Doc1.3/Python.html#Python_nn3">Preliminaries</A> 
  <UL>
    <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn4">Running 
    SWIG</A> 
    <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn5">Getting the 
    right header files</A> 
    <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn6">Compiling a 
    dynamic module</A> 
    <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn7">Using 
    distutils</A> 
    <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn8">Static 
    linking</A> 
    <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn9">Using your 
    module</A> 
    <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn10">Compilation 
    of C++ extensions</A> 
    <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn11">Compiling 
    for 64-bit platforms</A> 
    <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn12">Building 
    Python Extensions under Windows</A> </LI></UL>
  <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn13">A tour of 
  basic C/C++ wrapping</A> 
  <UL>
    <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn14">Modules</A> 

    <LI><A 
    href="http://www.swig.org/Doc1.3/Python.html#Python_nn15">Functions</A> 
    <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn16">Global 
    variables</A> 
    <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn17">Constants 
    and enums</A> 
    <LI><A 
    href="http://www.swig.org/Doc1.3/Python.html#Python_nn18">Pointers</A> 
    <LI><A 
    href="http://www.swig.org/Doc1.3/Python.html#Python_nn19">Structures</A> 
    <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn20">C++ 
    classes</A> 
    <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn21">C++ 
    inheritance</A> 
    <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn22">Pointers, 
    references, values, and arrays</A> 
    <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn23">C++ 
    overloaded functions</A> 
    <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn24">C++ 
    operators</A> 
    <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn25">C++ 
    namespaces</A> 
    <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn26">C++ 
    templates</A> 
    <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn27">C++ Smart 
    Pointers</A> 
    <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn27a">C++ 
    Reference Counted Objects (ref/unref)</A> </LI></UL>
  <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn28">Further 
  details on the Python class interface</A> 
  <UL>
    <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn29">Proxy 
    classes</A> 
    <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn30">Memory 
    management</A> 
    <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn31">Python 2.2 
    and classic classes</A> </LI></UL>
  <LI><A href="http://www.swig.org/Doc1.3/Python.html#directors">Cross language 
  polymorphism</A> 
  <UL>
    <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn33">Enabling 
    directors</A> 
    <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn34">Director 
    classes</A> 
    <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn35">Ownership 
    and object destruction</A> 
    <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn36">Exception 
    unrolling</A> 
    <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn37">Overhead 
    and code bloat</A> 
    <LI><A 
    href="http://www.swig.org/Doc1.3/Python.html#Python_nn38">Typemaps</A> 
    <LI><A 
    href="http://www.swig.org/Doc1.3/Python.html#Python_nn39">Miscellaneous</A> 
    </LI></UL>
  <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn40">Common 
  customization features</A> 
  <UL>
    <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn41">C/C++ 
    helper functions</A> 
    <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn42">Adding 
    additional Python code</A> 
    <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn43">Class 
    extension with %extend</A> 
    <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn44">Exception 
    handling with %exception</A> </LI></UL>
  <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn45">Tips and 
  techniques</A> 
  <UL>
    <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn46">Input and 
    output parameters</A> 
    <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn47">Simple 
    pointers</A> 
    <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn48">Unbounded C 
    Arrays</A> 
    <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn49">String 
    handling</A> 
    <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn50">Arrays</A> 
    <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn51">String 
    arrays</A> 
    <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn52">STL 
    wrappers</A> </LI></UL>
  <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn53">Typemaps</A> 
  <UL>
    <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn54">What is a 
    typemap?</A> 
    <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn55">Python 
    typemaps</A> 
    <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn56">Typemap 
    variables</A> 
    <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn57">Useful 
    Python Functions</A> </LI></UL>
  <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn58">Typemap 
  Examples</A> 
  <UL>
    <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn59">Converting 
    Python list to a char ** </A>
    <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn60">Expanding a 
    Python object into multiple arguments</A> 
    <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn61">Using 
    typemaps to return arguments</A> 
    <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn62">Mapping 
    Python tuples into small arrays</A> 
    <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn63">Mapping 
    sequences to C arrays</A> 
    <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn64">Pointer 
    handling</A> </LI></UL>
  <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn65">Docstring 
  Features</A> 
  <UL>
    <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn66">Module 
    docstring</A> 
    <LI><A 
    href="http://www.swig.org/Doc1.3/Python.html#Python_nn67">%feature("autodoc")</A> 

    <UL>
      <LI><A 
      href="http://www.swig.org/Doc1.3/Python.html#Python_nn68">%feature("autodoc", 
      "0")</A> 
      <LI><A 
      href="http://www.swig.org/Doc1.3/Python.html#Python_nn69">%feature("autodoc", 
      "1")</A> 
      <LI><A 
      href="http://www.swig.org/Doc1.3/Python.html#Python_nn70">%feature("autodoc", 
      "docstring")</A> </LI></UL>
    <LI><A 
    href="http://www.swig.org/Doc1.3/Python.html#Python_nn71">%feature("docstring")</A> 
    </LI></UL>
  <LI><A href="http://www.swig.org/Doc1.3/Python.html#Python_nn72">Python 
  Packages</A> </LI></UL></DIV><!-- INDEX -->
<P><B>Caution: This chapter is under repair!</B> </P>
<P>This chapter describes SWIG's support of Python. SWIG is compatible with most 
recent Python versions including Python 2.2 as well as older versions dating 
back to Python 1.5.2. For the best results, consider using Python 2.0 or newer. 
</P>
<P>This chapter covers most SWIG features, but certain low-level details are 
covered in less depth than in earlier chapters. At the very least, make sure you 
read the "<A href="http://www.swig.org/Doc1.3/SWIG.html#SWIG">SWIG Basics</A>" 
chapter. </P>
<H2><A name=Python_nn2></A>29.1 Overview</H2>
<P>To build Python extension modules, SWIG uses a layered approach in which 
parts of the extension module are defined in C and other parts are defined in 
Python. The C layer contains low-level wrappers whereas Python code is used to 
define high-level features. </P>
<P>This layered approach recognizes the fact that certain aspects of extension 
building are better accomplished in each language (instead of trying to do 
everything in C or C++). Furthermore, by generating code in both languages, you 
get a lot more flexibility since you can enhance the extension module with 
support code in either language. </P>
<P>In describing the Python interface, this chapter starts by covering the 
basics of configuration, compiling, and installing Python modules. Next, the 
Python interface to common C and C++ programming features is described. Advanced 
customization features such as typemaps are then described followed by a 
discussion of low-level implementation details. </P>
<H2><A name=Python_nn3></A>29.2 Preliminaries</H2>
<H3><A name=Python_nn4></A>29.2.1 Running SWIG</H3>
<P>Suppose that you defined a SWIG module such as the following: </P>
<DIV class=code><PRE>%module example
%{
#include "header.h"
%}
int fact(int n);
</PRE></DIV>
<P>To build a Python module, run SWIG using the <TT>-python</TT> option : </P>
<DIV class=shell><PRE>$ swig -python example.i
</PRE></DIV>
<P>If building a C++ extension, add the <TT>-c++</TT> option: </P>
<DIV class=shell><PRE>$ swig -c++ -python example.i
</PRE></DIV>
<P>This creates two different files; a C/C++ source file <TT>example_wrap.c</TT> 
or <TT>example_wrap.cxx</TT> and a Python source file <TT>example.py</TT>. The 
generated C source file contains the low-level wrappers that need to be compiled 
and linked with the rest of your C/C++ application to create an extension 
module. The Python source file contains high-level support code. This is the 
file that you will import to use the module. </P>
<P>The name of the wrapper file is derived from the name of the input file. For 
example, if the input file is <TT>example.i</TT>, the name of the wrapper file 
is <TT>example_wrap.c</TT>. To change this, you can use the <TT>-o</TT> option. 
The name of the Python file is derived from the module name specified with 
<TT>%module</TT>. If the module name is <TT>example</TT>, then a file 
<TT>example.py</TT> is created. </P>
<H3><A name=Python_nn5></A>29.2.2 Getting the right header files</H3>
<P>In order to compile the C/C++ wrappers, the compiler needs the 
<TT>Python.h</TT> header file. This file is usually contained in a directory 
such as </P>
<DIV class=diagram><PRE>/usr/local/include/python2.0
</PRE></DIV>
<P>The exact location may vary on your machine, but the above location is 
typical. If you are not entirely sure where Python is installed, you can run 
Python to find out. For example: </P>
<DIV class=targetlang><PRE>$ python
Python 2.1.1 (#1, Jul 23 2001, 14:36:06)
[GCC egcs-2.91.66 19990314/Linux (egcs-1.1.2 release)] on linux2
Type "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import sys
&gt;&gt;&gt; print sys.prefix
/usr/local
&gt;&gt;&gt;           
</PRE></DIV>
<H3><A name=Python_nn6></A>29.2.3 Compiling a dynamic module</H3>
<P>The preferred approach to building an extension module is to compile it into 
a shared object file or DLL. To do this, you need to compile your program using 
commands like this (shown for Linux): </P>
<DIV class=shell><PRE>$ swig -python example.i
$ gcc -c -fPIC example.c
$ gcc -c -fPIC example_wrap.c -I/usr/local/include/python2.0
$ gcc -shared example.o example_wrap.o -o _example.so
</PRE></DIV>
<P>The exact commands for doing this vary from platform to platform. However, 
SWIG tries to guess the right options when it is installed. Therefore, you may 
want to start with one of the examples in the <TT>SWIG/Examples/python</TT> 
directory. If that doesn't work, you will need to read the man-pages for your 
compiler and linker to get the right set of options. You might also check the <A 
href="http://www.dabeaz.com/cgi-bin/wiki.pl">SWIG Wiki</A> for additional 
information. </P>
<P>When linking the module, <B>the name of the output file has to match the name 
of the module prefixed by an underscore</B>. If the name of your module is 
"<TT>example</TT>", then the name of the corresponding object file should be 
"<TT>_example.so</TT>" or "<TT>_examplemodule.so</TT>". The name of the module 
is specified using the <TT>%module</TT> directive or the <TT>-module</TT> 
command line option. </P>
<P><B>Compatibility Note:</B> In SWIG-1.3.13 and earlier releases, module names 
did not include the leading underscore. This is because modules were normally 
created as C-only extensions without the extra Python support file (instead, 
creating Python code was supported as an optional feature). This has been 
changed in SWIG-1.3.14 and is consistent with other Python extension modules. 
For example, the <TT>socket</TT> module actually consists of two files; 
<TT>socket.py</TT> and <TT>_socket.so</TT>. Many other built-in Python modules 
follow a similar convention. </P>
<H3><A name=Python_nn7></A>29.2.4 Using distutils</H3>
<H3><A name=Python_nn8></A>29.2.5 Static linking</H3>
<P>An alternative approach to dynamic linking is to rebuild the Python 
interpreter with your extension module added to it. In the past, this approach 
was sometimes necessary due to limitations in dynamic loading support on certain 
machines. However, the situation has improved greatly over the last few years 
and you should not consider this approach unless there is really no other 
option. </P>
<P>The usual procedure for adding a new module to Python involves finding the 
Python source, adding an entry to the <TT>Modules/Setup</TT> file, and 
rebuilding the interpreter using the Python Makefile. However, newer Python 
versions have changed the build process. You may need to edit the 'setup.py' 
file in the Python distribution instead. </P>
<P>In earlier versions of SWIG, the <TT>embed.i</TT> library file could be used 
to rebuild the interpreter. For example: </P>
<DIV class=code><PRE>%module example

%inline %{
extern int fact(int);
extern int mod(int, int);
extern double My_variable;
%}

%include embed.i       // Include code for a static version of Python

</PRE></DIV>
<P>The <TT>embed.i</TT> library file includes supporting code that contains 
everything needed to rebuild Python. To rebuild the interpreter, you simply do 
something like this: </P>
<DIV class=shell><PRE>$ swig -python example.i
$ gcc example.c example_wrap.c \
        -Xlinker -export-dynamic \
        -DHAVE_CONFIG_H -I/usr/local/include/python2.1 \
	-I/usr/local/lib/python2.1/config \
	-L/usr/local/lib/python2.1/config -lpython2.1 -lm -ldl \
	-o mypython

</PRE></DIV>
<P>You will need to supply the same libraries that were used to build Python the 
first time. This may include system libraries such as <TT>-lsocket</TT>, 
<TT>-lnsl</TT>, and <TT>-lpthread</TT>. Assuming this actually works, the new 
version of Python should be identical to the default version except that your 
extension module will be a built-in part of the interpreter. </P>
<P><B>Comment:</B> In practice, you should probably try to avoid static linking 
if possible. Some programmers may be inclined to use static linking in the 
interest of getting better performance. However, the performance gained by 
static linking tends to be rather minimal in most situations (and quite frankly 
not worth the extra hassle in the opinion of this author). </P>
<P><B>Compatibility note:</B> The <TT>embed.i</TT> library file is deprecated 
and has not been maintained for several years. Even though it appears to "work" 
with Python 2.1, no future support is guaranteed. If using static linking, you 
might want to rely on a different approach (perhaps using distutils). </P>
<H3><A name=Python_nn9></A>29.2.6 Using your module</H3>
<P>To use your module, simply use the Python <TT>import</TT> statement. If all 
goes well, you will be able to this: </P>
<DIV class=targetlang><PRE>$ python
&gt;&gt;&gt; import example
&gt;&gt;&gt; example.fact(4)
24
&gt;&gt;&gt;
</PRE></DIV>
<P>A common error received by first-time users is the following: </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; import example
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
  File "example.py", line 2, in ?
    import _example
ImportError: No module named _example
</PRE></DIV>
<P>If you get this message, it means that you either forgot to compile the 
wrapper code into an extension module or you didn't give the extension module 
the right name. Make sure that you compiled the wrappers into a module called 
<TT>_example.so</TT>. And don't forget the leading underscore (_). </P>
<P>Another possible error is the following: </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; import example
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
ImportError: dynamic module does not define init function (init_example)
&gt;&gt;&gt;                                                               
</PRE></DIV>
<P>This error is almost always caused when a bad name is given to the shared 
object file. For example, if you created a file <TT>example.so</TT> instead of 
<TT>_example.so</TT> you would get this error. Alternatively, this error could 
arise if the name of the module is inconsistent with the module name supplied 
with the <TT>%module</TT> directive. Double-check the interface to make sure the 
module name and the shared object filename match. Another possible cause of this 
error is forgetting to link the SWIG-generated wrapper code with the rest of 
your application when creating the extension module. </P>
<P>Another common error is something similar to the following: </P>
<DIV class=targetlang><PRE>Traceback (most recent call last):
  File "example.py", line 3, in ?
    import example
ImportError: ./_example.so: undefined symbol: fact
</PRE></DIV>
<P>This error usually indicates that you forgot to include some object files or 
libraries in the linking of the shared library file. Make sure you compile both 
the SWIG wrapper file and your original program into a shared library file. Make 
sure you pass all of the required libraries to the linker. </P>
<P>Sometimes unresolved symbols occur because a wrapper has been created for a 
function that doesn't actually exist in a library. This usually occurs when a 
header file includes a declaration for a function that was never actually 
implemented or it was removed from a library without updating the header file. 
To fix this, you can either edit the SWIG input file to remove the offending 
declaration or you can use the <TT>%ignore</TT> directive to ignore the 
declaration. </P>
<P>Finally, suppose that your extension module is linked with another library 
like this: </P>
<DIV class=shell><PRE>$ gcc -shared example.o example_wrap.o -L/home/beazley/projects/lib <B>-lfoo</B> \
      -o _example.so
</PRE></DIV>
<P>If the <TT>foo</TT> library is compiled as a shared library, you might 
encounter the following problem when you try to use your module: </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; import example
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
ImportError: libfoo.so: cannot open shared object file: No such file or directory
&gt;&gt;&gt;                 
</PRE></DIV>
<P>This error is generated because the dynamic linker can't locate the 
<TT>libfoo.so</TT> library. When shared libraries are loaded, the system 
normally only checks a few standard locations such as <TT>/usr/lib</TT> and 
<TT>/usr/local/lib</TT>. To fix this problem, there are several things you can 
do. First, you can recompile your extension module with extra path information. 
For example, on Linux you can do this: </P>
<DIV class=shell><PRE>$ gcc -shared example.o example_wrap.o -L/home/beazley/projects/lib -lfoo \
      <B>-Xlinker -rpath /home/beazley/projects/lib </B> \
      -o _example.so
</PRE></DIV>
<P>Alternatively, you can set the <TT>LD_LIBRARY_PATH</TT> environment variable 
to include the directory with your shared libraries. If setting 
<TT>LD_LIBRARY_PATH</TT>, be aware that setting this variable can introduce a 
noticeable performance impact on all other applications that you run. To set it 
only for Python, you might want to do this instead: </P>
<DIV class=shell><PRE>$ env LD_LIBRARY_PATH=/home/beazley/projects/lib python
</PRE></DIV>
<P>Finally, you can use a command such as <TT>ldconfig</TT> (Linux) or 
<TT>crle</TT> (Solaris) to add additional search paths to the default system 
configuration (this requires root access and you will need to read the man 
pages). </P>
<H3><A name=Python_nn10></A>29.2.7 Compilation of C++ extensions</H3>
<P>Compilation of C++ extensions has traditionally been a tricky problem. Since 
the Python interpreter is written in C, you need to take steps to make sure C++ 
is properly initialized and that modules are compiled correctly. </P>
<P>On most machines, C++ extension modules should be linked using the C++ 
compiler. For example: </P>
<DIV class=shell><PRE>$ swig -c++ -python example.i
$ g++ -c example.cxx
$ g++ -c example_wrap.cxx -I/usr/local/include/python2.0
$ g++ -shared example.o example_wrap.o -o _example.so
</PRE></DIV>
<P>On some platforms, you could also need to generate position-independent code 
(PIC), by using a compiler option such as -fPIC. Notably, the x86_64 (Opteron 
and EM64T) platform requires it, and when using the GNU Compiler Suite, you will 
need to modify the previous example as follows: </P>
<DIV class=shell><PRE>$ swig -c++ -python example.i
$ g++ -fPIC -c example.cxx
$ g++ -fPIC -c example_wrap.cxx -I/usr/local/include/python2.0
$ g++ -shared example.o example_wrap.o -o _example.so
</PRE></DIV>
<P>In addition to this, you may need to include additional library files to make 
it work. For example, if you are using the Sun C++ compiler on Solaris, you 
often need to add an extra library <TT>-lCrun</TT> like this: </P>
<DIV class=shell><PRE>$ swig -c++ -python example.i
$ CC -c example.cxx
$ CC -c example_wrap.cxx -I/usr/local/include/python2.0
$ CC -G example.o example_wrap.o -L/opt/SUNWspro/lib -o _example.so -lCrun
</PRE></DIV>
<P>Of course, the extra libraries to use are completely non-portable---you will 
probably need to do some experimentation. </P>
<P>Sometimes people have suggested that it is necessary to relink the Python 
interpreter using the C++ compiler to make C++ extension modules work. In the 
experience of this author, this has never actually appeared to be necessary. 
Relinking the interpreter with C++ really only includes the special run-time 
libraries described above---as long as you link your extension modules with 
these libraries, it should not be necessary to rebuild Python. </P>
<P>If you aren't entirely sure about the linking of a C++ extension, you might 
look at an existing C++ program. On many Unix machines, the <TT>ldd</TT> command 
will list library dependencies. This should give you some clues about what you 
might have to include when you link your extension module. For example: </P>
<DIV class=shell><PRE>$ ldd swig
        libstdc++-libc6.1-1.so.2 =&gt; /usr/lib/libstdc++-libc6.1-1.so.2 (0x40019000)
        libm.so.6 =&gt; /lib/libm.so.6 (0x4005b000)
        libc.so.6 =&gt; /lib/libc.so.6 (0x40077000)
        /lib/ld-linux.so.2 =&gt; /lib/ld-linux.so.2 (0x40000000)
</PRE></DIV>
<P>As a final complication, a major weakness of C++ is that it does not define 
any sort of standard for binary linking of libraries. This means that C++ code 
compiled by different compilers will not link together properly as libraries nor 
is the memory layout of classes and data structures implemented in any kind of 
portable manner. In a monolithic C++ program, this problem may be unnoticed. 
However, in Python, it is possible for different extension modules to be 
compiled with different C++ compilers. As long as these modules are 
self-contained, this probably won't matter. However, if these modules start 
sharing data, you will need to take steps to avoid segmentation faults and other 
erratic program behavior. If working with lots of software components, you might 
want to investigate using a more formal standard such as COM. </P>
<H3><A name=Python_nn11></A>29.2.8 Compiling for 64-bit platforms</H3>
<P>On platforms that support 64-bit applications (Solaris, Irix, etc.), special 
care is required when building extension modules. On these machines, 64-bit 
applications are compiled and linked using a different set of compiler/linker 
options. In addition, it is not generally possible to mix 32-bit and 64-bit code 
together in the same application. </P>
<P>To utilize 64-bits, the Python executable will need to be recompiled as a 
64-bit application. In addition, all libraries, wrapper code, and every other 
part of your application will need to be compiled for 64-bits. If you plan to 
use other third-party extension modules, they will also have to be recompiled as 
64-bit extensions. </P>
<P>If you are wrapping commercial software for which you have no source code, 
you will be forced to use the same linking standard as used by that software. 
This may prevent the use of 64-bit extensions. It may also introduce problems on 
platforms that support more than one linking standard (e.g., -o32 and -n32 on 
Irix). </P>
<P>On the Linux x86_64 platform (Opteron or EM64T), besides of the required 
compiler option -fPIC discussed above, you will need to be careful about the 
libraries you link with or the library path you use. In general, a Linux 
distribution will have two set of libraries, one for native x86_64 programs 
(under /usr/lib64), and another for 32 bits compatibility (under /usr/lib). 
Also, the compiler options -m32 and -m64 allow you to choose the desired binary 
format for your python extension. </P>
<H3><A name=Python_nn12></A>29.2.9 Building Python Extensions under Windows</H3>
<P>Building a SWIG extension to Python under Windows is roughly similar to the 
process used with Unix. You will need to create a DLL that can be loaded into 
the interpreter. This section briefly describes the use of SWIG with Microsoft 
Visual C++. As a starting point, many of SWIG's examples include project files. 
You might want to take a quick look at these in addition to reading this 
section. </P>
<P>In Developer Studio, SWIG should be invoked as a custom build option. This is 
usually done as follows: </P>
<UL>
  <LI>Open up a new workspace and use the AppWizard to select a DLL project. 
  <LI>Add both the SWIG interface file (the .i file), any supporting C files, 
  and the name of the wrapper file that will be created by SWIG (ie. 
  <TT>example_wrap.c</TT>). Note : If using C++, choose a different suffix for 
  the wrapper file such as <TT>example_wrap.cxx</TT>. Don't worry if the wrapper 
  file doesn't exist yet--Developer Studio keeps a reference to it. 
  <LI>Select the SWIG interface file and go to the settings menu. Under 
  settings, select the "Custom Build" option. 
  <LI>Enter "SWIG" in the description field. 
  <LI>Enter "<TT>swig -python -o $(ProjDir)\$(InputName)_wrap.c 
  $(InputPath)</TT>" in the "Build command(s) field" 
  <LI>Enter "<TT>$(ProjDir)\$(InputName)_wrap.c</TT>" in the "Output files(s) 
  field". 
  <LI>Next, select the settings for the entire project and go to 
  "C++:Preprocessor". Add the include directories for your Python installation 
  under "Additional include directories". 
  <LI>Define the symbol __WIN32__ under preprocessor options. 
  <LI>Finally, select the settings for the entire project and go to "Link 
  Options". Add the Python library file to your link libraries. For example 
  "python21.lib". Also, set the name of the output file to match the name of 
  your Python module (ie. _example.dll). 
  <LI>Build your project. </LI></UL>
<P>If all went well, SWIG will be automatically invoked whenever you build your 
project. Any changes made to the interface file will result in SWIG being 
automatically executed to produce a new version of the wrapper file. </P>
<P>To run your new Python extension, simply run Python and use the 
<TT>import</TT> command as normal. For example : </P>
<DIV class=targetlang><PRE>$ python
&gt;&gt;&gt; import example
&gt;&gt;&gt; print example.fact(4)
24
&gt;&gt;&gt;
</PRE></DIV>
<P>If you get an <TT>ImportError</TT> exception when importing the module, you 
may have forgotten to include aditional library files when you built your 
module. If you get an access violation or some kind of general protection fault 
immediately upon import, you have a more serious problem. This is often caused 
by linking your extension module against the wrong set of Win32 debug or thread 
libraries. You will have to fiddle around with the build options of project to 
try and track this down. </P>
<P>Some users have reported success in building extension modules using Cygwin 
and other compilers. However, the problem of building usable DLLs with these 
compilers tends to be rather problematic. For the latest information, you may 
want to consult the <A href="http://www.dabeaz.com/cgi-bin/wiki.pl">SWIG 
Wiki</A>. </P>
<H2><A name=Python_nn13></A>29.3 A tour of basic C/C++ wrapping</H2>
<P>By default, SWIG tries to build a very natural Python interface to your C/C++ 
code. Functions are wrapped as functions, classes are wrapped as classes, and so 
forth. This section briefly covers the essential aspects of this wrapping. </P>
<H3><A name=Python_nn14></A>29.3.1 Modules</H3>
<P>The SWIG <TT>%module</TT> directive specifies the name of the Python module. 
If you specify `<TT>%module example</TT>', then everything is wrapped into a 
Python '<TT>example</TT>' module. Underneath the covers, this module consists of 
a Python source file <TT>example.py</TT> and a low-level extension module 
<TT>_example.so</TT>. When choosing a module name, make sure you don't use the 
same name as a built-in Python command or standard module name. </P>
<H3><A name=Python_nn15></A>29.3.2 Functions</H3>
<P>Global functions are wrapped as new Python built-in functions. For example, 
</P>
<DIV class=code><PRE>%module example
int fact(int n);
</PRE></DIV>
<P>creates a built-in function <TT>example.fact(n)</TT> that works exactly like 
you think it does: </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; import example
&gt;&gt;&gt; print example.fact(4)
24
&gt;&gt;&gt;
</PRE></DIV>
<H3><A name=Python_nn16></A>29.3.3 Global variables</H3>
<P>C/C++ global variables are fully supported by SWIG. However, the underlying 
mechanism is somewhat different than you might expect due to the way that Python 
assignment works. When you type the following in Python </P>
<DIV class=targetlang><PRE>a = 3.4
</PRE></DIV>
<P>"a" becomes a name for an object containing the value 3.4. If you later type 
</P>
<DIV class=targetlang><PRE>b = a
</PRE></DIV>
<P>then "a" and "b" are both names for the object containing the value 3.4. 
Thus, there is only one object containing 3.4 and "a" and "b" are both names 
that refer to it. This is quite different than C where a variable name refers to 
a memory location in which a value is stored (and assignment copies data into 
that location). Because of this, there is no direct way to map variable 
assignment in C to variable assignment in Python. </P>
<P>To provide access to C global variables, SWIG creates a special object called 
`<TT>cvar</TT>' that is added to each SWIG generated module. Global variables 
are then accessed as attributes of this object. For example, consider this 
interface </P>
<DIV class=code><PRE>// SWIG interface file with global variables
%module example
...
%inline %{
extern int My_variable;
extern double density;
%}
...
</PRE></DIV>
<P>Now look at the Python interface: </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; import example
&gt;&gt;&gt; # Print out value of a C global variable
&gt;&gt;&gt; print example.cvar.My_variable
4
&gt;&gt;&gt; # Set the value of a C global variable
&gt;&gt;&gt; example.cvar.density = 0.8442
&gt;&gt;&gt; # Use in a math operation
&gt;&gt;&gt; example.cvar.density = example.cvar.density*1.10
</PRE></DIV>
<P>If you make an error in variable assignment, you will receive an error 
message. For example: </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; example.cvar.density = "Hello"
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
TypeError: C variable 'density (double )'
&gt;&gt;&gt; 
</PRE></DIV>
<P>If a variable is declared as <TT>const</TT>, it is wrapped as a read-only 
variable. Attempts to modify its value will result in an error. </P>
<P>To make ordinary variables read-only, you can use the <TT>%immutable</TT> 
directive. For example: </P>
<DIV class=code><PRE>%{
extern char *path;
%}
%immutable;
extern char *path;
%mutable;
</PRE></DIV>
<P>The <TT>%immutable</TT> directive stays in effect until it is explicitly 
disabled or cleared using <TT>%mutable</TT>. See the <A 
href="http://www.swig.org/Doc1.3/SWIG.html#SWIG_readonly_variables">Creatng 
read-only variables</A> section for further details. </P>
<P>If you just want to make a specific variable immutable, supply a declaration 
name. For example: </P>
<DIV class=code><PRE>%{
extern char *path;
%}
%immutable path;
...
extern char *path;      // Read-only (due to %immutable)
</PRE></DIV>
<P>If you would like to access variables using a name other than 
"<TT>cvar</TT>", it can be changed using the <TT>-globals</TT> option : </P>
<DIV class=shell><PRE>$ swig -python -globals myvar example.i
</PRE></DIV>
<P>Some care is in order when importing multiple SWIG modules. If you use the 
"<TT>from &lt;file&gt; import *</TT>" style of importing, you will get a name 
clash on the variable `<TT>cvar</TT>' and you will only be able to access global 
variables from the last module loaded. To prevent this, you might consider 
renaming <TT>cvar</TT> or making it private to the module by giving it a name 
that starts with a leading underscore. SWIG does not create <TT>cvar</TT> if 
there are no global variables in a module. </P>
<H3><A name=Python_nn17></A>29.3.4 Constants and enums</H3>
<P>C/C++ constants are installed as Python objects containing the appropriate 
value. To create a constant, use <TT>#define</TT>, <TT>enum</TT>, or the 
<TT>%constant</TT> directive. For example: </P>
<DIV class=code><PRE>#define PI 3.14159
#define VERSION "1.0"

enum Beverage { ALE, LAGER, STOUT, PILSNER };

%constant int FOO = 42;
%constant const char *path = "/usr/local";
</PRE></DIV>
<P>For enums, make sure that the definition of the enumeration actually appears 
in a header file or in the wrapper file somehow---if you just stick an enum in a 
SWIG interface without also telling the C compiler about it, the wrapper code 
won't compile. </P>
<P>Note: declarations declared as <TT>const</TT> are wrapped as read-only 
variables and will be accessed using the <TT>cvar</TT> object described in the 
previous section. They are not wrapped as constants. For further discussion 
about this, see the <A href="http://www.swig.org/Doc1.3/SWIG.html#SWIG">SWIG 
Basics</A> chapter. </P>
<P>Constants are not guaranteed to remain constant in Python---the name of the 
constant could be accidentally reassigned to refer to some other object. 
Unfortunately, there is no easy way for SWIG to generate code that prevents 
this. You will just have to be careful. </P>
<H3><A name=Python_nn18></A>29.3.5 Pointers</H3>
<P>C/C++ pointers are fully supported by SWIG. Furthermore, SWIG has no problem 
working with incomplete type information. Here is a rather simple interface: 
</P>
<DIV class=code><PRE>%module example

FILE *fopen(const char *filename, const char *mode);
int fputs(const char *, FILE *);
int fclose(FILE *);
</PRE></DIV>
<P>When wrapped, you will be able to use the functions in a natural way from 
Python. For example: </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; import example
&gt;&gt;&gt; f = example.fopen("junk","w")
&gt;&gt;&gt; example.fputs("Hello World\n", f)
&gt;&gt;&gt; example.fclose(f)
</PRE></DIV>
<P>If this makes you uneasy, rest assured that there is no deep magic involved. 
Underneath the covers, pointers to C/C++ objects are simply represented as 
opaque values using an especial python container object: </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; print f
&lt;Swig Object at _08a71808_p_FILE&gt;
</PRE></DIV>
<P>This pointer value can be freely passed around to different C functions that 
expect to receive an object of type <TT>FILE *</TT>. The only thing you can't do 
is dereference the pointer from Python. Of course, that isn't much of a concern 
in this example. </P>
<P>In older versions of Swig (1.3.22 or older), pointers were represented using 
a plain string object. If you have an old package that still requires that 
representation, or you just feel nostalgic, you can always retreive it by 
casting the pointer object to a string: </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; print str(f)
_c0671108_p_FILE
</PRE></DIV>
<P>Also, if you need to pass the raw pointer value to some external python 
library, you can do it by casting the pointer object to an integer: </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; print int(f)
135833352
</PRE></DIV>
<P>However, the inverse operation is not possible, i.e., you can't build a Swig 
pointer object from a raw integer value. </P>
<P>Note also that the '0' or NULL pointer is always represented by 
<TT>None</TT>, no matter what type swig is addressing. In the previous example, 
you can call: </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; example.fclose(None)
</PRE></DIV>
<P>and that will be equivalent to the following, but not really useful, C code: 
</P>
<DIV class=code><PRE>FILE *f = NULL;
fclose(f);
</PRE></DIV>
<P>As much as you might be inclined to modify a pointer value directly from 
Python, don't. The hexadecimal encoding is not necessarily the same as the 
logical memory address of the underlying object. Instead it is the raw byte 
encoding of the pointer value. The encoding will vary depending on the native 
byte-ordering of the platform (i.e., big-endian vs. little-endian). Similarly, 
don't try to manually cast a pointer to a new type by simply replacing the 
type-string. This may not work like you expect, it is particularly dangerous 
when casting C++ objects. If you need to cast a pointer or change its value, 
consider writing some helper functions instead. For example: </P>
<DIV class=code><PRE>%inline %{
/* C-style cast */
Bar *FooToBar(Foo *f) {
   return (Bar *) f;
}

/* C++-style cast */
Foo *BarToFoo(Bar *b) {
   return dynamic_cast&lt;Foo*&gt;(b);
}

Foo *IncrFoo(Foo *f, int i) {
    return f+i;
}
%}
</PRE></DIV>
<P>Also, if working with C++, you should always try to use the new C++ style 
casts. For example, in the above code, the C-style cast may return a bogus 
result whereas as the C++-style cast will return <TT>None</TT> if the conversion 
can't be performed. </P>
<H3><A name=Python_nn19></A>29.3.6 Structures</H3>
<P>If you wrap a C structure, it is wrapped by a Python class. This provides a 
very natural interface. For example, </P>
<DIV class=code><PRE>struct Vector {
	double x,y,z;
};

</PRE></DIV>
<P>is used as follows: </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; v = example.Vector()
&gt;&gt;&gt; v.x = 3.5
&gt;&gt;&gt; v.y = 7.2
&gt;&gt;&gt; print v.x, v.y, v.z
7.8 -4.5 0.0
&gt;&gt;&gt; 
</PRE></DIV>
<P>Similar access is provided for unions and the data members of C++ classes. 
</P>
<P>If you print out the value of <TT>v</TT> in the above example, you will see 
something like this: </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; print v
&lt;C Vector instance at _18e31408_p_Vector&gt;
</PRE></DIV>
<P>This object is actually a Python instance that has been wrapped around a 
pointer to the low-level C structure. This instance doesn't actually do 
anything--it just serves as a proxy. The pointer to the C object can be found in 
the the <TT>.this</TT> attribute. For example: </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; print v.this
_18e31408_p_Vector
&gt;&gt;&gt;
</PRE></DIV>
<P>Further details about the Python proxy class are covered a little later. </P>
<P><TT>const</TT> members of a structure are read-only. Data members can also be 
forced to be read-only using the <TT>%immutable</TT> directive. For example: 
</P>
<DIV class=code><PRE>struct Foo {
   ...
   %immutable;
   int x;        /* Read-only members */
   char *name;
   %mutable;
   ...
};
</PRE></DIV>
<P>When <TT>char *</TT> members of a structure are wrapped, the contents are 
assumed to be dynamically allocated using <TT>malloc</TT> or <TT>new</TT> 
(depending on whether or not SWIG is run with the -c++ option). When the 
structure member is set, the old contents will be released and a new value 
created. If this is not the behavior you want, you will have to use a typemap 
(described later). </P>
<P>If a structure contains arrays, access to those arrays is managed through 
pointers. For example, consider this: </P>
<DIV class=code><PRE>struct Bar {
    int  x[16];
};
</PRE></DIV>
<P>If accessed in Python, you will see behavior like this: </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; b = example.Bar()
&gt;&gt;&gt; print b.x
_801861a4_p_int
&gt;&gt;&gt; 
</PRE></DIV>
<P>This pointer can be passed around to functions that expect to receive an 
<TT>int *</TT> (just like C). You can also set the value of an array member 
using another pointer. For example: </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; c = example.Bar()
&gt;&gt;&gt; c.x = b.x             # Copy contents of b.x to c.x
</PRE></DIV>
<P>For array assignment, SWIG copies the entire contents of the array starting 
with the data pointed to by <TT>b.x</TT>. In this example, 16 integers would be 
copied. Like C, SWIG makes no assumptions about bounds checking---if you pass a 
bad pointer, you may get a segmentation fault or access violation. </P>
<P>When a member of a structure is itself a structure, it is handled as a 
pointer. For example, suppose you have two structures like this: </P>
<DIV class=code><PRE>struct Foo {
   int a;
};

struct Bar {
   Foo f;
};
</PRE></DIV>
<P>Now, suppose that you access the <TT>f</TT> attribute of <TT>Bar</TT> like 
this: </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; b = Bar()
&gt;&gt;&gt; x = b.f
</PRE></DIV>
<P>In this case, <TT>x</TT> is a pointer that points to the <TT>Foo</TT> that is 
inside <TT>b</TT>. This is the same value as generated by this C code: </P>
<DIV class=code><PRE>Bar b;
Foo *x = &amp;b-&gt;f;       /* Points inside b */
</PRE></DIV>
<P>Because the pointer points inside the structure, you can modify the contents 
and everything works just like you would expect. For example: </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; b = Bar()
&gt;&gt;&gt; b.f.a = 3               # Modify attribute of structure member
&gt;&gt;&gt; x = b.f                   
&gt;&gt;&gt; x.a = 3                 # Modifies the same structure
</PRE></DIV>
<H3><A name=Python_nn20></A>29.3.7 C++ classes</H3>
<P>C++ classes are wrapped by Python classes as well. For example, if you have 
this class, </P>
<DIV class=code><PRE>class List {
public:
  List();
  ~List();
  int  search(char *item);
  void insert(char *item);
  void remove(char *item);
  char *get(int n);
  int  length;
};
</PRE></DIV>
<P>you can use it in Python like this: </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; l = example.List()
&gt;&gt;&gt; l.insert("Ale")
&gt;&gt;&gt; l.insert("Stout")
&gt;&gt;&gt; l.insert("Lager")
&gt;&gt;&gt; l.get(1)
'Stout'
&gt;&gt;&gt; print l.length
3
&gt;&gt;&gt;
</PRE></DIV>
<P>Class data members are accessed in the same manner as C structures. </P>
<P>Static class members present a special problem for Python. Prior to 
Python-2.2, Python classes had no support for static methods and no version of 
Python supports static member variables in a manner that SWIG can utilize. 
Therefore, SWIG generates wrappers that try to work around some of these issues. 
To illustrate, suppose you have a class like this: </P>
<DIV class=code><PRE>class Spam {
public:
   static void foo();
   static int bar;

};
</PRE></DIV>
<P>In Python, the static member can be access in three different ways: </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; example.Spam_foo()    # Spam::foo()
&gt;&gt;&gt; s = example.Spam()
&gt;&gt;&gt; s.foo()               # Spam::foo() via an instance
&gt;&gt;&gt; example.Spam.foo()    # Spam::foo(). Python-2.2 only
</PRE></DIV>
<P>The first two methods of access are supported in all versions of Python. The 
last technique is only available in Python-2.2 and later versions. </P>
<P>Static member variables are currently accessed as global variables. This 
means, they are accessed through <TT>cvar</TT> like this: </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; print example.cvar.Spam_bar
7
</PRE></DIV>
<H3><A name=Python_nn21></A>29.3.8 C++ inheritance</H3>
<P>SWIG is fully aware of issues related to C++ inheritance. Therefore, if you 
have classes like this </P>
<DIV class=code><PRE>class Foo {
...
};

class Bar : public Foo {
...
};
</PRE></DIV>
<P>those classes are wrapped into a hierarchy of Python classes that reflect the 
same inheritance structure. All of the usual Python utility functions work 
normally: </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; b = Bar()
&gt;&gt;&gt; instance(b,Foo)
1
&gt;&gt;&gt; issubclass(Bar,Foo)
1
&gt;&gt;&gt; issubclass(Foo,Bar)
0
</PRE></DIV>
<P>Furthermore, if you have functions like this </P>
<DIV class=code><PRE>void spam(Foo *f);
</PRE></DIV>
<P>then the function <TT>spam()</TT> accepts <TT>Foo *</TT> or a pointer to any 
class derived from <TT>Foo</TT>. </P>
<P>It is safe to use multiple inheritance with SWIG. </P>
<H3><A name=Python_nn22></A>29.3.9 Pointers, references, values, and arrays</H3>
<P>In C++, there are many different ways a function might receive and manipulate 
objects. For example: </P>
<DIV class=code><PRE>void spam1(Foo *x);      // Pass by pointer
void spam2(Foo &amp;x);      // Pass by reference
void spam3(const Foo &amp;x);// Pass by const reference
void spam4(Foo x);       // Pass by value
void spam5(Foo x[]);     // Array of objects
</PRE></DIV>
<P>In Python, there is no detailed distinction like this--specifically, there 
are only "objects". There are no pointers, references, arrays, and so forth. 
Because of this, SWIG unifies all of these types together in the wrapper code. 
For instance, if you actually had the above functions, it is perfectly legal to 
do this: </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; f = Foo()           # Create a Foo
&gt;&gt;&gt; spam1(f)            # Ok. Pointer
&gt;&gt;&gt; spam2(f)            # Ok. Reference
&gt;&gt;&gt; spam3(f)            # Ok. Const reference
&gt;&gt;&gt; spam4(f)            # Ok. Value.
&gt;&gt;&gt; spam5(f)            # Ok. Array (1 element)
</PRE></DIV>
<P>Similar behavior occurs for return values. For example, if you had functions 
like this, </P>
<DIV class=code><PRE>Foo *spam6();
Foo &amp;spam7();
Foo  spam8();
const Foo &amp;spam9();
</PRE></DIV>
<P>then all three functions will return a pointer to some <TT>Foo</TT> object. 
Since the third function (spam8) returns a value, newly allocated memory is used 
to hold the result and a pointer is returned (Python will release this memory 
when the return value is garbage collected). The fourth case (spam9) which 
returns a const reference, in most of the cases will be treated as a returning 
value, and it will follow the same allocation/deallocation process. </P>
<H3><A name=Python_nn23></A>29.3.10 C++ overloaded functions</H3>
<P>C++ overloaded functions, methods, and constructors are mostly supported by 
SWIG. For example, if you have two functions like this: </P>
<DIV class=code><PRE>void foo(int);
void foo(char *c);
</PRE></DIV>
<P>You can use them in Python in a straightforward manner: </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; foo(3)           # foo(int)
&gt;&gt;&gt; foo("Hello")     # foo(char *c)
</PRE></DIV>
<P>Similarly, if you have a class like this, </P>
<DIV class=code><PRE>class Foo {
public:
    Foo();
    Foo(const Foo &amp;);
    ...
};
</PRE></DIV>
<P>you can write Python code like this: </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; f = Foo()          # Create a Foo
&gt;&gt;&gt; g = Foo(f)         # Copy f
</PRE></DIV>
<P>Overloading support is not quite as flexible as in C++. Sometimes there are 
methods that SWIG can't disambiguate. For example: </P>
<DIV class=code><PRE>void spam(int);
void spam(short);
</PRE></DIV>
<P>or </P>
<DIV class=code><PRE>void foo(Bar *b);
void foo(Bar &amp;b);
</PRE></DIV>
<P>If declarations such as these appear, you will get a warning message like 
this: </P>
<DIV class=shell><PRE>example.i:12: Warning(509): Overloaded spam(short) is shadowed by spam(int)
at example.i:11.
</PRE></DIV>
<P>To fix this, you either need to ignore or rename one of the methods. For 
example: </P>
<DIV class=code><PRE>%rename(spam_short) spam(short);
...
void spam(int);    
void spam(short);   // Accessed as spam_short
</PRE></DIV>
<P>or </P>
<DIV class=code><PRE>%ignore spam(short);
...
void spam(int);    
void spam(short);   // Ignored
</PRE></DIV>
<P>SWIG resolves overloaded functions and methods using a disambiguation scheme 
that ranks and sorts declarations according to a set of type-precedence rules. 
The order in which declarations appear in the input does not matter except in 
situations where ambiguity arises--in this case, the first declaration takes 
precedence. </P>
<P>Please refer to the "SWIG and C++" chapter for more information about 
overloading. </P>
<H3><A name=Python_nn24></A>29.3.11 C++ operators</H3>
<P>Certain C++ overloaded operators can be handled automatically by SWIG. For 
example, consider a class like this: </P>
<DIV class=code><PRE>class Complex {
private:
  double rpart, ipart;
public:
  Complex(double r = 0, double i = 0) : rpart(r), ipart(i) { }
  Complex(const Complex &amp;c) : rpart(c.rpart), ipart(c.ipart) { }
  Complex &amp;operator=(const Complex &amp;c);

  Complex operator+=(const Complex &amp;c) const;
  Complex operator+(const Complex &amp;c) const;
  Complex operator-(const Complex &amp;c) const;
  Complex operator*(const Complex &amp;c) const;
  Complex operator-() const;
  
  double re() const { return rpart; }
  double im() const { return ipart; }
};
</PRE></DIV>
<P>When wrapped, it works like you expect: </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; c = Complex(3,4)
&gt;&gt;&gt; d = Complex(7,8)
&gt;&gt;&gt; e = c + d
&gt;&gt;&gt; e.re()
10.0
&gt;&gt;&gt; e.im()
12.0
&gt;&gt;&gt; c += d
&gt;&gt;&gt; c.re()
10.0
&gt;&gt;&gt; c.im()
12.0

</PRE></DIV>
<P>One restriction with operator overloading support is that SWIG is not able to 
fully handle operators that aren't defined as part of the class. For example, if 
you had code like this </P>
<DIV class=code><PRE>class Complex {
...
friend Complex operator+(double, const Complex &amp;c);
...
};
</PRE></DIV>
<P>then SWIG ignores it and issues a warning. You can still wrap the operator, 
but you may have to encapsulate it in a special function. For example: </P>
<DIV class=code><PRE>%rename(Complex_add_dc) operator+(double, const Complex &amp;);
</PRE></DIV>
<P>There are ways to make this operator appear as part of the class using the 
<TT>%extend</TT> directive. Keep reading. </P>
<P>Also, be aware that certain operators don't map cleanly to Python. For 
instance, overloaded assignment operators don't map to Python semantics and will 
be ignored. </P>
<H3><A name=Python_nn25></A>29.3.12 C++ namespaces</H3>
<P>SWIG is aware of C++ namespaces, but namespace names do not appear in the 
module nor do namespaces result in a module that is broken up into submodules or 
packages. For example, if you have a file like this, </P>
<DIV class=code><PRE>%module example

namespace foo {
   int fact(int n);
   struct Vector {
       double x,y,z;
   };
};
</PRE></DIV>
<P>it works in Python as follows: </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; import example
&gt;&gt;&gt; example.fact(3)
6
&gt;&gt;&gt; v = example.Vector()
&gt;&gt;&gt; v.x = 3.4
&gt;&gt;&gt; print v.y
0.0
&gt;&gt;&gt;
</PRE></DIV>
<P>If your program has more than one namespace, name conflicts (if any) can be 
resolved using <TT>%rename</TT> For example: </P>
<DIV class=code><PRE>%rename(Bar_spam) Bar::spam;

namespace Foo {
    int spam();
}

namespace Bar {
    int spam();
}
</PRE></DIV>
<P>If you have more than one namespace and your want to keep their symbols 
separate, consider wrapping them as separate SWIG modules. For example, make the 
module name the same as the namespace and create extension modules for each 
namespace separately. If your program utilizes thousands of small deeply nested 
namespaces each with identical symbol names, well, then you get what you 
deserve. </P>
<H3><A name=Python_nn26></A>29.3.13 C++ templates</H3>
<P>C++ templates don't present a huge problem for SWIG. However, in order to 
create wrappers, you have to tell SWIG to create wrappers for a particular 
template instantiation. To do this, you use the <TT>%template</TT> directive. 
For example: </P>
<DIV class=code><PRE>%module example
%{
#include "pair.h"
%}

template&lt;class T1, class T2&gt;
struct pair {
   typedef T1 first_type;
   typedef T2 second_type;
   T1 first;
   T2 second;
   pair();
   pair(const T1&amp;, const T2&amp;);
  ~pair();
};

%template(pairii) pair&lt;int,int&gt;;
</PRE></DIV>
<P>In Python: </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; import example
&gt;&gt;&gt; p = example.pairii(3,4)
&gt;&gt;&gt; p.first
3
&gt;&gt;&gt; p.second
4
</PRE></DIV>
<P>Obviously, there is more to template wrapping than shown in this example. 
More details can be found in the <A 
href="http://www.swig.org/Doc1.3/SWIGPlus.html#SWIGPlus">SWIG and C++</A> 
chapter. Some more complicated examples will appear later. </P>
<H3><A name=Python_nn27></A>29.3.14 C++ Smart Pointers</H3>
<P>In certain C++ programs, it is common to use classes that have been wrapped 
by so-called "smart pointers." Generally, this involves the use of a template 
class that implements <TT>operator-&gt;()</TT> like this: </P>
<DIV class=code><PRE>template&lt;class T&gt; class SmartPtr {
   ...
   T *operator-&gt;();
   ...
}
</PRE></DIV>
<P>Then, if you have a class like this, </P>
<DIV class=code><PRE>class Foo {
public:
     int x;
     int bar();
};
</PRE></DIV>
<P>A smart pointer would be used in C++ as follows: </P>
<DIV class=code><PRE>SmartPtr&lt;Foo&gt; p = CreateFoo();   // Created somehow (not shown)
...
p-&gt;x = 3;                        // Foo::x
int y = p-&gt;bar();                // Foo::bar
</PRE></DIV>
<P>To wrap this in Python, simply tell SWIG about the <TT>SmartPtr</TT> class 
and the low-level <TT>Foo</TT> object. Make sure you instantiate 
<TT>SmartPtr</TT> using <TT>%template</TT> if necessary. For example: </P>
<DIV class=code><PRE>%module example
...
%template(SmartPtrFoo) SmartPtr&lt;Foo&gt;;
...
</PRE></DIV>
<P>Now, in Python, everything should just "work": </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; p = example.CreateFoo()          # Create a smart-pointer somehow
&gt;&gt;&gt; p.x = 3                          # Foo::x
&gt;&gt;&gt; p.bar()                          # Foo::bar
</PRE></DIV>
<P>If you ever need to access the underlying pointer returned by 
<TT>operator-&gt;()</TT> itself, simply use the <TT>__deref__()</TT> method. For 
example: </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; f = p.__deref__()     # Returns underlying Foo *
</PRE></DIV>
<H3><A name=Python_nn27a></A>29.3.15 C++ Reference Counted Objects 
(ref/unref)</H3>
<P>Another usual idiom in C++ is the use of reference counted objects. Consider 
for example: 
<DIV class=code><PRE>class RCObj  {
  // implement the ref counting mechanism
  int add_ref();
  int del_ref();
  int ref_count();

public:
  virtual ~RCObj() = 0;

  int ref() const {
    return add_ref();
  }

  int unref() const   {
    if (ref_count() == 0 || del_ref() == 0 ) {
	delete this;
	return 0;
      } 
    return ref_count();
  }
};


class A : RCObj {
public:
  A();
  int foo();
};


class B {
  A *_a;

public:
  B(A *a) : _a(a) { 
    a-&gt;ref(); 
  }

  ~B() { 
    a-&gt;unref(); 
  }
};

int main() {
  A *a  = new A();
  a-&gt;ref();           // 'a' is ref here

  B *b1 = new B(a);   // 'a' is ref here
  if (1 + 1 == 2) {
    B *b2 = new B(a); // 'a' is ref here
    delete b2;        // 'a' is unref, but not deleted   
  }

  delete b1;          // 'a' is unref, but not deleted   
  a-&gt;unref();         // 'a' is unref and deleted
}
</PRE></DIV>
<P>In the example above, the 'A' class instance 'a' is a reference counted 
object, which can't be deleted arbitrarily since it is shared between the 
objects 'b1' and 'b2'. 'A' is derived from an Reference Counted Object 'RCObj', 
which implements the ref/unref idiom. </P>
<P>To tell SWIG that 'RCObj' and all its derived classes are reference counted 
objects, you use the "ref" and "unref" features, or <TT>%ref</TT> and 
<TT>%unref</TT> directives (since 1.3.28). For example: </P>
<DIV class=code><PRE>%module example
...

%feature("ref")   RCObj "$this-&gt;ref();"
%feature("unref") RCObj "$this-&gt;unref();"

%include "rcobj.h"
%include "A.h"
...
</PRE></DIV>or, using the directive form: 
<DIV class=code><PRE>%module example
...

%ref   RCObj "$this-&gt;ref();"
%unref RCObj "$this-&gt;unref();"

%include "rcobj.h"
%include "A.h"
...
</PRE></DIV>
<P>where the code passed to the "ref" and "unref" features will be executed as 
needed whenever a new object is passed to python, or when python tries to 
release the shadow object instance, respectively. </P>
<P>In the python side, the use of a reference counted object is not different 
than any other regular instance: </P>
<DIV class=targetlang><PRE>def create_A():
  a = A()         # SWIG ref 'a' (new object is passed to python)
  b1 = B(a)       # C++  ref 'a'
  if 1 + 1 == 2:
     b2 = B(a)    # C++ ref 'a'
  return a        # 'b1' and 'b2' are released, C++ unref 'a' twice

a = create_A()   
exit              # 'a' is released, SWIG unref 'a'
</PRE></DIV>
<P>Note that the user doens't explicitly need to call 'a-&gt;ref()' nor 
'a-&gt;unref()' (as neither 'delete a'). Instead, SWIG take cares of executing 
the "ref" and "unref" codes as needed. If the user doesn't specify the 
"ref/unref" features, SWIG will produce a code equivalent to define them as: 
</P>
<DIV class=code><PRE>%feature("ref")   ""
%feature("unref") "delete $this;"
</PRE></DIV>
<P>In other words, SWIG will not do anything special when a new object is passed 
to python, and it will always 'delete' the object when python releases the proxy 
instance. </P>
<H2><A name=Python_nn28></A>29.4 Further details on the Python class 
interface</H2>
<P>In the previous section, a high-level view of Python wrapping was presented. 
A key component of this wrapping is that structures and classes are wrapped by 
Python proxy classes. This provides a very natural Python interface and allows 
SWIG to support a number of advanced features such as operator overloading. 
However, a number of low-level details were omitted. This section provides a 
brief overview of how the proxy classes work. </P>
<H3><A name=Python_nn29></A>29.4.1 Proxy classes</H3>
<P>In the <A href="http://www.swig.org/Doc1.3/SWIG.html#SWIG">"SWIG basics"</A> 
and <A href="http://www.swig.org/Doc1.3/SWIGPlus.html#SWIGPlus">"SWIG and 
C++"</A> chapters, details of low-level structure and class wrapping are 
described. To summarize those chapters, if you have a class like this </P>
<DIV class=code><PRE>class Foo {
public:
     int x;
     int spam(int);
     ...
</PRE></DIV>
<P>then SWIG transforms it into a set of low-level procedural wrappers. For 
example: </P>
<DIV class=code><PRE>Foo *new_Foo() {
    return new Foo();
}
void delete_Foo(Foo *f) {
    delete f;
}
int Foo_x_get(Foo *f) {
    return f-&gt;x;
}
void Foo_x_set(Foo *f, int value) {
    f-&gt;x = value;
}
int Foo_spam(Foo *f, int arg1) {
    return f-&gt;spam(arg1);
}
</PRE></DIV>
<P>These wrappers can be found in the low-level extension module (e.g., 
<TT>_example</TT>). </P>
<P>Using these wrappers, SWIG generates a high-level Python proxy class (also 
known as a shadow class) like this (shown for Python 2.2): </P>
<DIV class=targetlang><PRE>import _example

class Foo(object):
     def __init__(self):
         self.this = _example.new_Foo()
         self.thisown = 1
     def __del__(self):
         if self.thisown:
               _example.delete_Foo(self.this)
     def spam(self,arg1):
         return _example.Foo_spam(self.this,arg1)
     x = property(_example.Foo_x_get, _example.Foo_x_set)
</PRE></DIV>
<P>This class merely holds a pointer to the underlying C++ object 
(<TT>.this</TT>) and dispatches methods and member variable access to that 
object using the low-level accessor functions. From a user's point of view, it 
makes the class work normally: </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; f = example.Foo()
&gt;&gt;&gt; f.x = 3
&gt;&gt;&gt; y = f.spam(5)
</PRE></DIV>
<P>The fact that the class has been wrapped by a real Python class offers 
certain advantages. For instance, you can attach new Python methods to the class 
and you can even inherit from it (something not supported by Python built-in 
types until Python 2.2). </P>
<H3><A name=Python_nn30></A>29.4.2 Memory management</H3>
<P>Associated with proxy object, is an ownership flag <TT>.thisown</TT> The 
value of this flag determines who is responsible for deleting the underlying C++ 
object. If set to 1, the Python interpreter will destroy the C++ object when the 
proxy class is garbage collected. If set to 0 (or if the attribute is missing), 
then the destruction of the proxy class has no effect on the C++ object. </P>
<P>When an object is created by a constructor or returned by value, Python 
automatically takes ownership of the result. For example: </P>
<DIV class=code><PRE>class Foo {
public:
    Foo();
    Foo bar();
};
</PRE></DIV>
<P>In Python: </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; f = Foo()
&gt;&gt;&gt; f.thisown
1
&gt;&gt;&gt; g = f.bar()
&gt;&gt;&gt; g.thisown
1
</PRE></DIV>
<P>On the other hand, when pointers are returned to Python, there is often no 
way to know where they came from. Therefore, the ownership is set to zero. For 
example: </P>
<DIV class=code><PRE>class Foo {
public:
    ...
    Foo *spam();
    ...
};
</PRE></DIV><BR>
<DIV class=targetlang><PRE>&gt;&gt;&gt; f = Foo()
&gt;&gt;&gt; s = f.spam()
&gt;&gt;&gt; print s.thisown
0
&gt;&gt;&gt;
</PRE></DIV>
<P>This behavior is especially important for classes that act as containers. For 
example, if a method returns a pointer to an object that is contained inside 
another object, you definitely don't want Python to assume ownership and destroy 
it! </P>
<P>Related to containers, ownership issues can arise whenever an object is 
assigned to a member or global variable. For example, consider this interface: 
</P>
<DIV class=code><PRE>%module example

struct Foo {
    int  value;
    Foo  *next;
};

Foo *head = 0;
</PRE></DIV>
<P>When wrapped in Python, careful observation will reveal that ownership 
changes whenever an object is assigned to a global variable. For example: </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; f = example.Foo()
&gt;&gt;&gt; f.thisown
1
&gt;&gt;&gt; example.cvar.head = f           
&gt;&gt;&gt; f.thisown
0
&gt;&gt;&gt;
</PRE></DIV>
<P>In this case, C is now holding a reference to the object---you probably don't 
want Python to destroy it. Similarly, this occurs for members. For example: </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; f = example.Foo()
&gt;&gt;&gt; g = example.Foo()
&gt;&gt;&gt; f.thisown
1
&gt;&gt;&gt; g.thisown
1
&gt;&gt;&gt; f.next = g
&gt;&gt;&gt; g.thisown
0
&gt;&gt;&gt;
</PRE></DIV>
<P>For the most part, memory management issues remain hidden. However, there are 
occasionally situations where you might have to manually change the ownership of 
an object. For instance, consider code like this: </P>
<DIV class=code><PRE>class Node {
   Object *value;
public:
   void set_value(Object *v) { value = v; }
   ...
};
</PRE></DIV>
<P>Now, consider the following Python code: </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; v = Object()           # Create an object
&gt;&gt;&gt; n = Node()             # Create a node
&gt;&gt;&gt; n.set_value(v)         # Set value
&gt;&gt;&gt; v.thisown
1
&gt;&gt;&gt; del v
</PRE></DIV>
<P>In this case, the object <TT>n</TT> is holding a reference to <TT>v</TT> 
internally. However, SWIG has no way to know that this has occurred. Therefore, 
Python still thinks that it has ownership of the object. Should the proxy object 
be destroyed, then the C++ destructor will be invoked and <TT>n</TT> will be 
holding a stale-pointer. If you're lucky, you will only get a segmentation 
fault. </P>
<P>To work around this, it is always possible to flip the ownership flag. For 
example, </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; v.thisown = 0
</PRE></DIV>
<P>It is also possible to deal with situations like this using typemaps--an 
advanced topic discussed later. </P>
<H3><A name=Python_nn31></A>29.4.3 Python 2.2 and classic classes</H3>
<P>SWIG makes every attempt to preserve backwards compatibility with older 
versions of Python to the extent that it is possible. However, in Python-2.2, an 
entirely new type of class system was introduced. This new-style class system 
offers many enhancements including static member functions, properties (managed 
attributes), and class methods. Details about all of these changes can be found 
on <A href="http://www.python.org/">http://www.python.org/</A> and is not 
repeated here. </P>
<P>To address differences between Python versions, SWIG currently emits 
dual-mode proxy class wrappers. In Python-2.2 and newer releases, these wrappers 
encapsulate C++ objects in new-style classes that take advantage of new features 
(static methods and properties). However, if these very same wrappers are 
imported into an older version of Python, old-style classes are used instead. 
</P>
<P>This dual-nature of the wrapper code means that you can create extension 
modules with SWIG and those modules will work with all versions of Python 
ranging from Python-1.4 to the very latest release. Moreover, the wrappers take 
advantage of Python-2.2 features when available. </P>
<P>For the most part, the interface presented to users is the same regardless of 
what version of Python is used. The only incompatibility lies in the handling of 
static member functions. In Python-2.2, they can be accessed via the class 
itself. In Python-2.1 and earlier, they have to be accessed as a global function 
or through an instance (see the earlier section). </P>
<H2><A name=directors></A>29.5 Cross language polymorphism</H2>
<P>Proxy classes provide a more natural, object-oriented way to access extension 
classes. As described above, each proxy instance has an associated C++ instance, 
and method calls to the proxy are passed to the C++ instance transparently via C 
wrapper functions. </P>
<P>This arrangement is asymmetric in the sense that no corresponding mechanism 
exists to pass method calls down the inheritance chain from C++ to Python. In 
particular, if a C++ class has been extended in Python (by extending the proxy 
class), these extensions will not be visible from C++ code. Virtual method calls 
from C++ are thus not able access the lowest implementation in the inheritance 
chain. </P>
<P>Changes have been made to SWIG 1.3.18 to address this problem and make the 
relationship between C++ classes and proxy classes more symmetric. To achieve 
this goal, new classes called directors are introduced at the bottom of the C++ 
inheritance chain. The job of the directors is to route method calls correctly, 
either to C++ implementations higher in the inheritance chain or to Python 
implementations lower in the inheritance chain. The upshot is that C++ classes 
can be extended in Python and from C++ these extensions look exactly like native 
C++ classes. Neither C++ code nor Python code needs to know where a particular 
method is implemented: the combination of proxy classes, director classes, and C 
wrapper functions takes care of all the cross-language method routing 
transparently. </P>
<H3><A name=Python_nn33></A>29.5.1 Enabling directors</H3>
<P>The director feature is disabled by default. To use directors you must make 
two changes to the interface file. First, add the "directors" option to the 
%module directive, like this: </P>
<DIV class=code><PRE>%module(directors="1") modulename
</PRE></DIV>
<P>Without this option no director code will be generated. Second, you must use 
the %feature("director") directive to tell SWIG which classes and methods should 
get directors. The %feature directive can be applied globally, to specific 
classes, and to specific methods, like this: </P>
<DIV class=code><PRE>// generate directors for all classes that have virtual methods
%feature("director");         

// genarate directors for all virtual methods in class Foo
%feature("director") Foo;      

// generate a director for just Foo::bar()
%feature("director") Foo::bar; 
</PRE></DIV>
<P>You can use the %feature("nodirector") directive to turn off directors for 
specific classes or methods. So for example, </P>
<DIV class=code><PRE>%feature("director") Foo;
%feature("nodirector") Foo::bar;
</PRE></DIV>
<P>will generate directors for all virtual methods of class Foo except bar(). 
</P>
<P>Directors can also be generated implicitly through inheritance. In the 
following, class Bar will get a director class that handles the methods one() 
and two() (but not three()): </P>
<DIV class=code><PRE>%feature("director") Foo;
class Foo {
public:
    Foo(int foo);
    virtual void one();
    virtual void two();
};

class Bar: public Foo {
public:
    virtual void three();
};
</PRE></DIV>
<P>then at the python side you can define </P>
<DIV class=targetlang><PRE>import mymodule

class MyFoo(mymodule.Foo):
  def __init__(self, foo):
     mymodule.Foo(self, foo)  

  def one(self):
     print "one from python"
</PRE></DIV>
<H3><A name=Python_nn34></A>29.5.2 Director classes</H3>
<P>For each class that has directors enabled, SWIG generates a new class that 
derives from both the class in question and a special <TT>Swig::Director</TT> 
class. These new classes, referred to as director classes, can be loosely 
thought of as the C++ equivalent of the Python proxy classes. The director 
classes store a pointer to their underlying Python object and handle various 
issues related to object ownership. Indeed, this is quite similar to the "this" 
and "thisown" members of the Python proxy classes. </P>
<P>For simplicity let's ignore the <TT>Swig::Director</TT> class and refer to 
the original C++ class as the director's base class. By default, a director 
class extends all virtual methods in the inheritance chain of its base class 
(see the preceding section for how to modify this behavior). Thus all virtual 
method calls, whether they originate in C++ or in Python via proxy classes, 
eventually end up in at the implementation in the director class. The job of the 
director methods is to route these method calls to the appropriate place in the 
inheritance chain. By "appropriate place" we mean the method that would have 
been called if the C++ base class and its extensions in Python were seamlessly 
integrated. That seamless integration is exactly what the director classes 
provide, transparently skipping over all the messy extension API glue that binds 
the two languages together. </P>
<P>In reality, the "appropriate place" is one of only two possibilities: C++ or 
Python. Once this decision is made, the rest is fairly easy. If the correct 
implementation is in C++, then the lowest implementation of the method in the 
C++ inheritance chain is called explicitly. If the correct implementation is in 
Python, the Python API is used to call the method of the underlying Python 
object (after which the usual virtual method resolution in Python automatically 
finds the right implementation). </P>
<P>Now how does the director decide which language should handle the method 
call? The basic rule is to handle the method in Python, unless there's a good 
reason not to. The reason for this is simple: Python has the most "extended" 
implementation of the method. This assertion is guaranteed, since at a minimum 
the Python proxy class implements the method. If the method in question has been 
extended by a class derived from the proxy class, that extended implementation 
will execute exactly as it should. If not, the proxy class will route the method 
call into a C wrapper function, expecting that the method will be resolved in 
C++. The wrapper will call the virtual method of the C++ instance, and since the 
director extends this the call will end up right back in the director method. 
Now comes the "good reason not to" part. If the director method were to blindly 
call the Python method again, it would get stuck in an infinite loop. We avoid 
this situation by adding special code to the C wrapper function that tells the 
director method to not do this. The C wrapper function compares the pointer to 
the Python object that called the wrapper function to the pointer stored by the 
director. If these are the same, then the C wrapper function tells the director 
to resolve the method by calling up the C++ inheritance chain, preventing an 
infinite loop. </P>
<P>One more point needs to be made about the relationship between director 
classes and proxy classes. When a proxy class instance is created in Python, 
SWIG creates an instance of the original C++ class and assigns it to 
<TT>.this</TT>. This is exactly what happens without directors and is true even 
if directors are enabled for the particular class in question. When a class 
<I>derived</I> from a proxy class is created, however, SWIG then creates an 
instance of the corresponding C++ director class. The reason for this difference 
is that user-defined subclasses may override or extend methods of the original 
class, so the director class is needed to route calls to these methods 
correctly. For unmodified proxy classes, all methods are ultimately implemented 
in C++ so there is no need for the extra overhead involved with routing the 
calls through Python. </P>
<H3><A name=Python_nn35></A>29.5.3 Ownership and object destruction</H3>
<P>Memory management issues are slightly more complicated with directors than 
for proxy classes alone. Python instances hold a pointer to the associated C++ 
director object, and the director in turn holds a pointer back to the Python 
object. By default, proxy classes own their C++ director object and take care of 
deleting it when they are garbage collected. </P>
<P>This relationship can be reversed by calling the special 
<TT>__disown__()</TT> method of the proxy class. After calling this method, the 
<TT>.thisown</TT> flag is set to zero, and the director class increments the 
reference count of the Python object. When the director class is deleted it 
decrements the reference count. Assuming no outstanding references to the Python 
object remain, the Python object will be destroyed at the same time. This is a 
good thing, since directors and proxies refer to each other and so must be 
created and destroyed together. Destroying one without destroying the other will 
likely cause your program to segfault. </P>
<P>To help ensure that no references to the Python object remain after calling 
<TT>__disown__()</TT>, this method returns a weak reference to the Python 
object. Weak references are only available in Python versions 2.1 and higher, so 
for older versions you must exclicitly delete all references. Here is an 
example: </P>
<DIV class=code><PRE>class Foo {
public:
    ...
};
class FooContainer {
public:
    void addFoo(Foo *);
    ...
};
</PRE></DIV><BR>
<DIV class=targetlang><PRE>&gt;&gt;&gt; c = FooContainer()
&gt;&gt;&gt; a = Foo().__disown()__
&gt;&gt;&gt; c.addFoo(a)
&gt;&gt;&gt; b = Foo()
&gt;&gt;&gt; b = b.__disown()__
&gt;&gt;&gt; c.addFoo(b)
&gt;&gt;&gt; c.addFoo(Foo().__disown()__)
</PRE></DIV>
<P>In this example, we are assuming that FooContainer will take care of deleting 
all the Foo pointers it contains at some point. Note that no hard references to 
the Foo objects remain in Python. </P>
<H3><A name=Python_nn36></A>29.5.4 Exception unrolling</H3>
<P>With directors routing method calls to Python, and proxies routing them to 
C++, the handling of exceptions is an important concern. By default, the 
directors ignore exceptions that occur during method calls that are resolved in 
Python. To handle such exceptions correctly, it is necessary to temporarily 
translate them into C++ exceptions. This can be done with the 
%feature("director:except") directive. The following code should suffice in most 
cases: </P>
<DIV class=code><PRE>%feature("director:except") {
    if ($error != NULL) {
        throw Swig::DirectorMethodException();
    }
}
</PRE></DIV>
<P>This code will check the Python error state after each method call from a 
director into Python, and throw a C++ exception if an error occured. This 
exception can be caught in C++ to implement an error handler. Currently no 
information about the Python error is stored in the 
Swig::DirectorMethodException object, but this will likely change in the future. 
</P>
<P>It may be the case that a method call originates in Python, travels up to C++ 
through a proxy class, and then back into Python via a director method. If an 
exception occurs in Python at this point, it would be nice for that exception to 
find its way back to the original caller. This can be done by combining a normal 
%exception directive with the <TT>director:except</TT> handler shown above. Here 
is an example of a suitable exception handler: </P>
<DIV class=code><PRE>%exception {
    try { $action }
    catch (Swig::DirectorException &amp;e) { SWIG_fail; }
}
</PRE></DIV>
<P>The class Swig::DirectorException used in this example is actually a base 
class of Swig::DirectorMethodException, so it will trap this exception. Because 
the Python error state is still set when Swig::DirectorMethodException is 
thrown, Python will register the exception as soon as the C wrapper function 
returns. </P>
<H3><A name=Python_nn37></A>29.5.5 Overhead and code bloat</H3>
<P>Enabling directors for a class will generate a new director method for every 
virtual method in the class' inheritance chain. This alone can generate a lot of 
code bloat for large hierarchies. Method arguments that require complex 
conversions to and from target language types can result in large director 
methods. For this reason it is recommended that you selectively enable directors 
only for specific classes that are likely to be extended in Python and used in 
C++. </P>
<P>Compared to classes that do not use directors, the call routing in the 
director methods does add some overhead. In particular, at least one dynamic 
cast and one extra function call occurs per method call from Python. Relative to 
the speed of Python execution this is probably completely negligible. For worst 
case routing, a method call that ultimately resolves in C++ may take one extra 
detour through Python in order to ensure that the method does not have an 
extended Python implementation. This could result in a noticible overhead in 
some cases. </P>
<P>Although directors make it natural to mix native C++ objects with Python 
objects (as director objects) via a common base class pointer, one should be 
aware of the obvious fact that method calls to Python objects will be much 
slower than calls to C++ objects. This situation can be optimized by selectively 
enabling director methods (using the %feature directive) for only those methods 
that are likely to be extended in Python. </P>
<H3><A name=Python_nn38></A>29.5.6 Typemaps</H3>
<P>Typemaps for input and output of most of the basic types from director 
classes have been written. These are roughly the reverse of the usual input and 
output typemaps used by the wrapper code. The typemap operation names are 
'directorin', 'directorout', and 'directorargout'. The director code does not 
currently use any of the other kinds of typemaps. It is not clear at this point 
which kinds are appropriate and need to be supported. </P>
<H3><A name=Python_nn39></A>29.5.7 Miscellaneous</H3>
<P>Director typemaps for STL classes are in place, and hence you should be able 
to use std::vector, std::string, etc., as you would any other type. </P>
<P><B>Note:</B> The director typemaps for return types based in const 
references, such as 
<DIV class=code><PRE>class Foo {

    virtual const int&amp; bar();

};
</PRE></DIV>
<P>will work only for simple call scenarios. Usually the resulting code is 
neither thread or reentrant safe. Hence, the user is advised to avoid returning 
const references in director methods. For example, the user could modify the 
method interface to use lvalue return types, wherever possible, for example </P>
<DIV class=code><PRE>class Foo {

    virtual int bar();

};
</PRE></DIV>
<P>If that is not possible, the user should avoid enabling the director feature 
for reentrant, recursive or threaded member methods that return const 
references. </P>
<H2><A name=Python_nn40></A>29.6 Common customization features</H2>
<P>The last section presented the absolute basics of C/C++ wrapping. If you do 
nothing but feed SWIG a header file, you will get an interface that mimics the 
behavior described. However, sometimes this isn't enough to produce a nice 
module. Certain types of functionality might be missing or the interface to 
certain functions might be awkward. This section describes some common SWIG 
features that are used to improve your the interface to an extension module. 
</P>
<H3><A name=Python_nn41></A>29.6.1 C/C++ helper functions</H3>
<P>Sometimes when you create a module, it is missing certain bits of 
functionality. For example, if you had a function like this </P>
<DIV class=code><PRE>void set_transform(Image *im, double m[4][4]);
</PRE></DIV>
<P>it would be accessible from Python, but there may be no easy way to call it. 
For example, you might get errors like this: </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; a = [
...   [1,0,0,0],
...   [0,1,0,0],
...   [0,0,1,0],
...   [0,0,0,1]]
&gt;&gt;&gt; set_transform(im,a)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
TypeError: Type error. Expected _p_a_4__double
</PRE></DIV>
<P>The problem here is that there is no easy way to construct and manipulate a 
suitable <TT>double [4][4]</TT> value to use. To fix this, you can write some 
extra C helper functions. Just use the <TT>%inline</TT> directive. For example: 
</P>
<DIV class=code><PRE>%inline %{
/* Note: double[4][4] is equivalent to a pointer to an array double (*)[4] */
double (*new_mat44())[4] {
   return (double (*)[4]) malloc(16*sizeof(double));
}
void free_mat44(double (*x)[4]) {
   free(x);
}
void mat44_set(double x[4][4], int i, int j, double v) {
   x[i][j] = v;
}
double mat44_get(double x[4][4], int i, int j) {
   return x[i][j];
}
%}
</PRE></DIV>
<P>From Python, you could then write code like this: </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; a = new_mat44()
&gt;&gt;&gt; mat44_set(a,0,0,1.0)
&gt;&gt;&gt; mat44_set(a,1,1,1.0)
&gt;&gt;&gt; mat44_set(a,2,2,1.0)
...
&gt;&gt;&gt; set_transform(im,a)
&gt;&gt;&gt;
</PRE></DIV>
<P>Admittedly, this is not the most elegant looking approach. However, it works 
and it wasn't too hard to implement. It is possible to clean this up using 
Python code, typemaps, and other customization features as covered in later 
sections. </P>
<H3><A name=Python_nn42></A>29.6.2 Adding additional Python code</H3>
<P>If writing support code in C isn't enough, it is also possible to write code 
in Python. This code gets inserted in to the <TT>.py</TT> file created by SWIG. 
One use of Python code might be to supply a high-level interface to certain 
functions. For example: </P>
<DIV class=code><PRE>void set_transform(Image *im, double x[4][4]);

...
/* Rewrite the high level interface to set_transform */
%pythoncode %{
def set_transform(im,x):
   a = new_mat44()
   for i in range(4):
       for j in range(4):
           mat44_set(a,i,j,x[i][j])
   _example.set_transform(im,a)
   free_mat44(a)
%}
</PRE></DIV>
<P>In this example, <TT>set_transform()</TT> provides a high-level Python 
interface built on top of low-level helper functions. For example, this code now 
seems to work: </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; a = [
...   [1,0,0,0],
...   [0,1,0,0],
...   [0,0,1,0],
...   [0,0,0,1]]
&gt;&gt;&gt; set_transform(im,a)
&gt;&gt;&gt;
</PRE></DIV>
<P>Admittedly, this whole scheme for wrapping the two-dimension array argument 
is rather ad-hoc. Besides, shouldn't a Python list or a Numeric Python array 
just work normally? We'll get to those examples soon enough. For now, think of 
this example as an illustration of what can be done without having to rely on 
any of the more advanced customization features. </P>
<P>Sometimes you may want to replace or modify the wrapper function that SWIG 
creates in the proxy <TT>.py</TT> file. The Python module in SWIG provides some 
features that enable you do do this. First, to entirely replace a proxy function 
you can use <TT>%feature("shadow")</TT>. For example:</P>
<DIV class=code><PRE>%module example

// Rewrite bar() python code

%feature("shadow") Foo::bar(int) %{
def bar(*args):
    #do something before
    $action
    #do something after
%}
    
class Foo {
public:
    int bar(int x);
}
</PRE></DIV>
<P>where <TT>$action</TT> will be replaced by the call to the C/C++ proper 
method. </P>
<P>Often the proxy function created by SWIG is fine, but you simply want to add 
code to it without touching the rest of the generated function body. For these 
cases SWIG provides the <TT>pythonprepend</TT> and <TT>pythonappend</TT> 
features which do exactly as their names suggest. The <TT>pythonprepend</TT> 
feature will insert its value at the begining of the proxy function, and 
<TT>pythonappend</TT> will insert code at the end of the proxy, just before the 
return statement. </P>
<DIV class=code><PRE>%module example

// Add python code to bar() 

%feature("pythonprepend") Foo::bar(int) %{
   #do something before C++ call
%}

%feature("pythonappend") Foo::bar(int) %{
   #do something after C++ call
%}

    
class Foo {
public:
    int bar(int x);
}
</PRE></DIV>
<P>Notes: Usually the <TT>pythonappend</TT> and <TT>pythonprepend</TT> features 
are safer to use than the <TT>shadow</TT> feature. Also, from SWIG version 
1.3.28 you can use the directive forms <TT>%pythonappend</TT> and 
<TT>%pythonprepend</TT> as follows:</P>
<DIV class=code><PRE>%module example

// Add python code to bar() 

%pythonprepend Foo::bar(int) %{
   #do something before C++ call
%}

%pythonappend Foo::bar(int) %{
   #do something after C++ call
%}

    
class Foo {
public:
    int bar(int x);
}
</PRE></DIV>
<H3><A name=Python_nn43></A>29.6.3 Class extension with %extend</H3>
<P>One of the more interesting features of SWIG is that it can extend structures 
and classes with new methods--at least in the Python interface. Here is a simple 
example: </P>
<DIV class=code><PRE>%module example
%{
#include "someheader.h"
%}

struct Vector {
   double x,y,z;
};

%extend Vector {
   char *__str__() {
       static char tmp[1024];
       sprintf(tmp,"Vector(%g,%g,%g)", self-&gt;x,self-&gt;y,self-&gt;z);
       return tmp;
   }
   Vector(double x, double y, double z) {
       Vector *v = (Vector *) malloc(sizeof(Vector));
       v-&gt;x = x;
       v-&gt;y = y;
       v-&gt;z = z;
       return v;
   }
};
</PRE></DIV>
<P>Now, in Python </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; v = example.Vector(2,3,4)
&gt;&gt;&gt; print v
Vector(2,3,4)
&gt;&gt;&gt;
</PRE></DIV>
<P><TT>%extend</TT> can be used for many more tasks than this. For example, if 
you wanted to overload a Python operator, you might do this: </P>
<DIV class=code><PRE>%extend Vector {
    Vector __add__(Vector *other) {
         Vector v;
         v.x = self-&gt;x + other-&gt;x;
         v.y = self-&gt;y + other-&gt;y;
         v.z = self-&gt;z + other-&gt;z;
         return v;
    }
};
</PRE></DIV>
<P>Use it like this: </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; import example
&gt;&gt;&gt; v = example.Vector(2,3,4)
&gt;&gt;&gt; w = example.Vector(10,11,12)
&gt;&gt;&gt; print v+w
Vector(12,14,16)
&gt;&gt;&gt; 
</PRE></DIV>
<P><TT>%extend</TT> works with both C and C++ code. It does not modify the 
underlying object in any way---the extensions only show up in the Python 
interface. </P>
<H3><A name=Python_nn44></A>29.6.4 Exception handling with %exception</H3>
<P>If a C or C++ function throws an error, you may want to convert that error 
into a Python exception. To do this, you can use the <TT>%exception</TT> 
directive. <TT>%exception</TT> simply lets you rewrite part of the generated 
wrapper code to include an error check. </P>
<P>In C, a function often indicates an error by returning a status code (a 
negative number or a NULL pointer perhaps). Here is a simple example of how you 
might handle that: </P>
<DIV class=code><PRE>%exception malloc {
  $action
  if (!result) {
     PyErr_SetString(PyExc_MemoryError,"Not enough memory");
     return NULL;
  }
}
void *malloc(size_t nbytes);
</PRE></DIV>
<P>In Python, </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; a = example.malloc(2000000000)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
MemoryError: Not enough memory
&gt;&gt;&gt;
</PRE></DIV>
<P>If a library provides some kind of general error handling framework, you can 
also use that. For example: </P>
<DIV class=code><PRE>%exception {
   $action
   if (err_occurred()) {
      PyErr_SetString(PyExc_RuntimeError, err_message());
      return NULL;
   }
}
</PRE></DIV>
<P>No declaration name is given to <TT>%exception</TT>, it is applied to all 
wrapper functions. </P>
<P>C++ exceptions are also easy to handle. For example, you can write code like 
this: </P>
<DIV class=code><PRE>%exception getitem {
   try {
      $action
   } catch (std::out_of_range &amp;e) {
      PyErr_SetString(PyExc_IndexError, const_cast&lt;char*&gt;(e.what()));
      return NULL;
   }
}

class Base {
public:
     Foo *getitem(int index);      // Exception handled added
     ...
};
</PRE></DIV>
<P>When raising a Python exception from C, use the <TT>PyErr_SetString()</TT> 
function as shown above. The following exception types can be used as the first 
argument. </P>
<DIV class=code><PRE>PyExc_ArithmeticError
PyExc_AssertionError
PyExc_AttributeError
PyExc_EnvironmentError
PyExc_EOFError
PyExc_Exception
PyExc_FloatingPointError
PyExc_ImportError
PyExc_IndexError
PyExc_IOError
PyExc_KeyError
PyExc_KeyboardInterrupt
PyExc_LookupError
PyExc_MemoryError
PyExc_NameError
PyExc_NotImplementedError
PyExc_OSError
PyExc_OverflowError
PyExc_RuntimeError
PyExc_StandardError
PyExc_SyntaxError
PyExc_SystemError
PyExc_TypeError
PyExc_UnicodeError
PyExc_ValueError
PyExc_ZeroDivisionError
</PRE></DIV>
<P>The language-independent <TT>exception.i</TT> library file can also be used 
to raise exceptions. See the <A 
href="http://www.swig.org/Doc1.3/Library.html#Library">SWIG Library</A> chapter. 
</P>
<H2><A name=Python_nn45></A>29.7 Tips and techniques</H2>
<P>Although SWIG is largely automatic, there are certain types of wrapping 
problems that require additional user input. Examples include dealing with 
output parameters, strings, binary data, and arrays. This chapter discusses the 
common techniques for solving these problems. </P>
<H3><A name=Python_nn46></A>29.7.1 Input and output parameters</H3>
<P>A common problem in some C programs is handling parameters passed as simple 
pointers. For example: </P>
<DIV class=code><PRE>void add(int x, int y, int *result) {
   *result = x + y;
}
</PRE></DIV>
<P>or perhaps </P>
<DIV class=code><PRE>int sub(int *x, int *y) {
   return *x-*y;
}
</PRE></DIV>
<P>The easiest way to handle these situations is to use the <TT>typemaps.i</TT> 
file. For example: </P>
<DIV class=code><PRE>%module example
%include "typemaps.i"

void add(int, int, int *OUTPUT);
int  sub(int *INPUT, int *INPUT);
</PRE></DIV>
<P>In Python, this allows you to pass simple values. For example: </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; a = add(3,4)
&gt;&gt;&gt; print a
7
&gt;&gt;&gt; b = sub(7,4)
&gt;&gt;&gt; print b
3
&gt;&gt;&gt;
</PRE></DIV>
<P>Notice how the <TT>INPUT</TT> parameters allow integer values to be passed 
instead of pointers and how the <TT>OUTPUT</TT> parameter creates a return 
result. </P>
<P>If you don't want to use the names <TT>INPUT</TT> or <TT>OUTPUT</TT>, use the 
<TT>%apply</TT> directive. For example: </P>
<DIV class=code><PRE>%module example
%include "typemaps.i"

%apply int *OUTPUT { int *result };
%apply int *INPUT  { int *x, int *y};

void add(int x, int y, int *result);
int  sub(int *x, int *y);
</PRE></DIV>
<P>If a function mutates one of its parameters like this, </P>
<DIV class=code><PRE>void negate(int *x) {
   *x = -(*x);
}
</PRE></DIV>
<P>you can use <TT>INOUT</TT> like this: </P>
<DIV class=code><PRE>%include "typemaps.i"
...
void negate(int *INOUT);
</PRE></DIV>
<P>In Python, a mutated parameter shows up as a return value. For example: </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; a = negate(3)
&gt;&gt;&gt; print a
-3
&gt;&gt;&gt;
</PRE></DIV>
<P>Note: Since most primitive Python objects are immutable, it is not possible 
to perform in-place modification of a Python object passed as a parameter. </P>
<P>The most common use of these special typemap rules is to handle functions 
that return more than one value. For example, sometimes a function returns a 
result as well as a special error code: </P>
<DIV class=code><PRE>/* send message, return number of bytes sent, along with success code */
int send_message(char *text, int len, int *success);
</PRE></DIV>
<P>To wrap such a function, simply use the <TT>OUTPUT</TT> rule above. For 
example: </P>
<DIV class=code><PRE>%module example
%include "typemaps.i"
%apply int *OUTPUT { int *success };
...
int send_message(char *text, int *success);
</PRE></DIV>
<P>When used in Python, the function will return multiple values. </P>
<DIV class=targetlang><PRE>bytes, success = send_message("Hello World")
if not success:
    print "Whoa!"
else:
    print "Sent", bytes
</PRE></DIV>
<P>Another common use of multiple return values are in query functions. For 
example: </P>
<DIV class=code><PRE>void get_dimensions(Matrix *m, int *rows, int *columns);
</PRE></DIV>
<P>To wrap this, you might use the following: </P>
<DIV class=code><PRE>%module example
%include "typemaps.i"
%apply int *OUTPUT { int *rows, int *columns };
...
void get_dimensions(Matrix *m, int *rows, *columns);
</PRE></DIV>
<P>Now, in Python: </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; r,c = get_dimensions(m)
</PRE></DIV>
<P>Be aware that the primary purpose of the <TT>typemaps.i</TT> file is to 
support primitive datatypes. Writing a function like this </P>
<DIV class=code><PRE>void foo(Bar *OUTPUT);
</PRE></DIV>
<P>may not have the intended effect since <TT>typemaps.i</TT> does not define an 
OUTPUT rule for <TT>Bar</TT>. </P>
<H3><A name=Python_nn47></A>29.7.2 Simple pointers</H3>
<P>If you must work with simple pointers such as <TT>int *</TT> or <TT>double 
*</TT> and you don't want to use <TT>typemaps.i</TT>, consider using the 
<TT>cpointer.i</TT> library file. For example: </P>
<DIV class=code><PRE>%module example
%include "cpointer.i"

%inline %{
extern void add(int x, int y, int *result);
%}

%pointer_functions(int, intp);
</PRE></DIV>
<P>The <TT>%pointer_functions(type,name)</TT> macro generates five helper 
functions that can be used to create, destroy, copy, assign, and dereference a 
pointer. In this case, the functions are as follows: </P>
<DIV class=code><PRE>int  *new_intp();
int  *copy_intp(int *x);
void  delete_intp(int *x);
void  intp_assign(int *x, int value);
int   intp_value(int *x);
</PRE></DIV>
<P>In Python, you would use the functions like this: </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; result = new_intp()
&gt;&gt;&gt; print result
_108fea8_p_int
&gt;&gt;&gt; add(3,4,result)
&gt;&gt;&gt; print intp_value(result)
7
&gt;&gt;&gt;
</PRE></DIV>
<P>If you replace <TT>%pointer_functions()</TT> by 
<TT>%pointer_class(type,name)</TT>, the interface is more class-like. </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; result = intp()
&gt;&gt;&gt; add(3,4,result)
&gt;&gt;&gt; print result.value()
7
</PRE></DIV>
<P>See the <A href="http://www.swig.org/Doc1.3/Library.html#Library">SWIG 
Library</A> chapter for further details. </P>
<H3><A name=Python_nn48></A>29.7.3 Unbounded C Arrays</H3>
<P>Sometimes a C function expects an array to be passed as a pointer. For 
example, </P>
<DIV class=code><PRE>int sumitems(int *first, int nitems) {
    int i, sum = 0;
    for (i = 0; i &lt; nitems; i++) {
        sum += first[i];
    }
    return sum;
}
</PRE></DIV>
<P>To wrap this into Python, you need to pass an array pointer as the first 
argument. A simple way to do this is to use the <TT>carrays.i</TT> library file. 
For example: </P>
<DIV class=code><PRE>%include "carrays.i"
%array_class(int, intArray);
</PRE></DIV>
<P>The <TT>%array_class(type, name)</TT> macro creates wrappers for an unbounded 
array object that can be passed around as a simple pointer like <TT>int *</TT> 
or <TT>double *</TT>. For instance, you will be able to do this in Python: </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; a = intArray(10000000)         # Array of 10-million integers
&gt;&gt;&gt; for i in xrange(10000):        # Set some values
...     a[i] = i
&gt;&gt;&gt; sumitems(a,10000)
49995000
&gt;&gt;&gt;
</PRE></DIV>
<P>The array "object" created by <TT>%array_class()</TT> does not encapsulate 
pointers inside a special array object. In fact, there is no bounds checking or 
safety of any kind (just like in C). Because of this, the arrays created by this 
library are extremely low-level indeed. You can't iterate over them nor can you 
even query their length. In fact, any valid memory address can be accessed if 
you want (negative indices, indices beyond the end of the array, etc.). Needless 
to say, this approach is not going to suit all applications. On the other hand, 
this low-level approach is extremely efficient and well suited for applications 
in which you need to create buffers, package binary data, etc. </P>
<H3><A name=Python_nn49></A>29.7.4 String handling</H3>
<P>If a C function has an argument of <TT>char *</TT>, then a Python string can 
be passed as input. For example: </P>
<DIV class=code><PRE>// C
void foo(char *s);
</PRE></DIV>
<DIV class=targetlang><PRE># Python
&gt;&gt;&gt; foo("Hello")
</PRE></DIV>
<P>When a Python string is passed as a parameter, the C function receives a 
pointer to the raw data contained in the string. Since Python strings are 
immutable, it is illegal for your program to change the value. In fact, doing so 
will probably crash the Python interpreter. </P>
<P>If your program modifies the input parameter or uses it to return data, 
consider using the <TT>cstring.i</TT> library file described in the <A 
href="http://www.swig.org/Doc1.3/Library.html#Library">SWIG Library</A> chapter. 
</P>
<P>When functions return a <TT>char *</TT>, it is assumed to be a 
NULL-terminated string. Data is copied into a new Python string and returned. 
</P>
<P>If your program needs to work with binary data, you can use a typemap to 
expand a Python string into a pointer/length argument pair. As luck would have 
it, just such a typemap is already defined. Just do this: </P>
<DIV class=code><PRE>%apply (char *STRING, int LENGTH) { (char *data, int size) };
...
int parity(char *data, int size, int initial);
</PRE></DIV>
<P>Now in Python: </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; parity("e\x09ffss\x00\x00\x01\nx", 0)
</PRE></DIV>
<P>If you need to return binary data, you might use the <TT>cstring.i</TT> 
library file. The <TT>cdata.i</TT> library can also be used to extra binary data 
from arbitrary pointers. </P>
<H3><A name=Python_nn50></A>29.7.5 Arrays</H3>
<H3><A name=Python_nn51></A>29.7.6 String arrays</H3>
<H3><A name=Python_nn52></A>29.7.7 STL wrappers</H3>
<H2><A name=Python_nn53></A>29.8 Typemaps</H2>
<P>This section describes how you can modify SWIG's default wrapping behavior 
for various C/C++ datatypes using the <TT>%typemap</TT> directive. This is an 
advanced topic that assumes familiarity with the Python C API as well as the 
material in the "<A 
href="http://www.swig.org/Doc1.3/Typemaps.html#Typemaps">Typemaps</A>" chapter. 
</P>
<P>Before proceeding, it should be stressed that typemaps are not a required 
part of using SWIG---the default wrapping behavior is enough in most cases. 
Typemaps are only used if you want to change some aspect of the primitive 
C-Python interface or if you want to elevate your guru status. </P>
<H3><A name=Python_nn54></A>29.8.1 What is a typemap?</H3>
<P>A typemap is nothing more than a code generation rule that is attached to a 
specific C datatype. For example, to convert integers from Python to C, you 
might define a typemap like this: </P>
<DIV class=code><PRE>%module example

%typemap(in) int {
	$1 = (int) PyLong_AsLong($input);
	printf("Received an integer : %d\n",$1);
}
%inline %{
extern int fact(int n);
%}
</PRE></DIV>
<P>Typemaps are always associated with some specific aspect of code generation. 
In this case, the "in" method refers to the conversion of input arguments to 
C/C++. The datatype <TT>int</TT> is the datatype to which the typemap will be 
applied. The supplied C code is used to convert values. In this code a number of 
special variable prefaced by a <TT>$</TT> are used. The <TT>$1</TT> variable is 
placeholder for a local variable of type <TT>int</TT>. The <TT>$input</TT> 
variable is the input object of type <TT>PyObject *</TT>. </P>
<P>When this example is compiled into a Python module, it operates as follows: 
</P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; from example import *
&gt;&gt;&gt; fact(6)
Received an integer : 6
720
</PRE></DIV>
<P>In this example, the typemap is applied to all occurrences of the 
<TT>int</TT> datatype. You can refine this by supplying an optional parameter 
name. For example: </P>
<DIV class=code><PRE>%module example

%typemap(in) int nonnegative {
	$1 = (int) PyLong_AsLong($input);
        if ($1 &lt; 0) {
           PyErr_SetString(PyExc_ValueError,"Expected a nonnegative value.");
           return NULL;
        }
}
%inline %{
extern int fact(int nonnegative);
%}
</PRE></DIV>
<P>In this case, the typemap code is only attached to arguments that exactly 
match <TT>int nonnegative</TT>. </P>
<P>The application of a typemap to specific datatypes and argument names 
involves more than simple text-matching--typemaps are fully integrated into the 
SWIG C++ type-system. When you define a typemap for <TT>int</TT>, that typemap 
applies to <TT>int</TT> and qualified variations such as <TT>const int</TT>. In 
addition, the typemap system follows <TT>typedef</TT> declarations. For example: 
</P>
<DIV class=code><PRE>%typemap(in) int n {
	$1 = (int) PyLong_AsLong($input);
	printf("n = %d\n",$1);
}
%inline %{
typedef int Integer;
extern int fact(Integer n);    // Above typemap is applied
%}
</PRE></DIV>
<P>Typemaps can also be defined for groups of consecutive arguments. For 
example: </P>
<DIV class=code><PRE>%typemap(in) (char *str, int len) {
    $1 = PyString_AsString($input);
    $2 = PyString_Size($input);
};

int count(char c, char *str, int len);
</PRE></DIV>
<P>When a multi-argument typemap is defined, the arguments are always handled as 
a single Python object. This allows the function to be used like this (notice 
how the length parameter is omitted): </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; example.count('e','Hello World')
1
&gt;&gt;&gt;
</PRE></DIV>
<H3><A name=Python_nn55></A>29.8.2 Python typemaps</H3>
<P>The previous section illustrated an "in" typemap for converting Python 
objects to C. A variety of different typemap methods are defined by the Python 
module. For example, to convert a C integer back into a Python object, you might 
define an "out" typemap like this: </P>
<DIV class=code><PRE>%typemap(out) int {
    $result = PyInt_FromLong((long) $1);
}
</PRE></DIV>
<P>A detailed list of available methods can be found in the "<A 
href="http://www.swig.org/Doc1.3/Typemaps.html#Typemaps">Typemaps</A>" chapter. 
</P>
<P>However, the best source of typemap information (and examples) is probably 
the Python module itself. In fact, all of SWIG's default type handling is 
defined by typemaps. You can view these typemaps by looking at the files in the 
SWIG library. Just take into account that in the latest versions of swig 
(1.3.22+), the library files are not very pristine clear for the casual reader, 
as they used to be. The extensive use of macros and other ugly techniques in the 
latest version produce a very powerful and consistent python typemap library, 
but at the cost of simplicity and pedagogic value. </P>
<P>To learn how to write a simple or your first typemap, you better take a look 
at the SWIG library version 1.3.20 or so. </P>
<H3><A name=Python_nn56></A>29.8.3 Typemap variables</H3>
<P>Within typemap code, a number of special variables prefaced with a <TT>$</TT> 
may appear. A full list of variables can be found in the "<A 
href="http://www.swig.org/Doc1.3/Typemaps.html#Typemaps">Typemaps</A>" chapter. 
This is a list of the most common variables: </P>
<P><TT>$1</TT> </P>
<DIV class=indent>A C local variable corresponding to the actual type specified 
in the <TT>%typemap</TT> directive. For input values, this is a C local variable 
that's supposed to hold an argument value. For output values, this is the raw 
result that's supposed to be returned to Python. </DIV>
<P><TT>$input</TT> </P>
<DIV class=indent>A <TT>PyObject *</TT> holding a raw Python object with an 
argument or variable value. </DIV>
<P><TT>$result</TT> </P>
<DIV class=indent>A <TT>PyObject *</TT> that holds the result to be returned to 
Python. </DIV>
<P><TT>$1_name</TT> </P>
<DIV class=indent>The parameter name that was matched. </DIV>
<P><TT>$1_type</TT> </P>
<DIV class=indent>The actual C datatype matched by the typemap. </DIV>
<P><TT>$1_ltype</TT> </P>
<DIV class=indent>An assignable version of the datatype matched by the typemap 
(a type that can appear on the left-hand-side of a C assignment operation). This 
type is stripped of qualifiers and may be an altered version of 
<TT>$1_type</TT>. All arguments and local variables in wrapper functions are 
declared using this type so that their values can be properly assigned. </DIV>
<P><TT>$symname</TT> </P>
<DIV class=indent>The Python name of the wrapper function being created. </DIV>
<H3><A name=Python_nn57></A>29.8.4 Useful Python Functions</H3>
<P>When you write a typemap, you usually have to work directly with Python 
objects. The following functions may prove to be useful. </P>
<P><B>Python Integer Functions</B> </P>
<DIV class=code><PRE>PyObject *PyInt_FromLong(long l);
long      PyInt_AsLong(PyObject *);
int       PyInt_Check(PyObject *);
</PRE></DIV>
<P><B>Python Floating Point Functions</B> </P>
<DIV class=code><PRE>PyObject *PyFloat_FromDouble(double);
double    PyFloat_AsDouble(PyObject *);
int       PyFloat_Check(PyObject *);
</PRE></DIV>
<P><B>Python String Functions</B> </P>
<DIV class=code><PRE>PyObject *PyString_FromString(char *);
PyObject *PyString_FromStringAndSize(char *, lint len);
int       PyString_Size(PyObject *);
char     *PyString_AsString(PyObject *);
int       PyString_Check(PyObject *);
</PRE></DIV>
<P><B>Python List Functions</B> </P>
<DIV class=code><PRE>PyObject *PyList_New(int size);
int       PyList_Size(PyObject *list);
PyObject *PyList_GetItem(PyObject *list, int i);
int       PyList_SetItem(PyObject *list, int i, PyObject *item);
int       PyList_Insert(PyObject *list, int i, PyObject *item);
int       PyList_Append(PyObject *list, PyObject *item);
PyObject *PyList_GetSlice(PyObject *list, int i, int j);
int       PyList_SetSlice(PyObject *list, int i, int , PyObject *list2);
int       PyList_Sort(PyObject *list);
int       PyList_Reverse(PyObject *list);
PyObject *PyList_AsTuple(PyObject *list);
int       PyList_Check(PyObject *);
</PRE></DIV>
<P><B>Python Tuple Functions</B> </P>
<DIV class=code><PRE>PyObject *PyTuple_New(int size);
int       PyTuple_Size(PyObject *);
PyObject *PyTuple_GetItem(PyObject *, int i);
int       PyTuple_SetItem(PyObject *, int i, pyObject *item);
PyObject *PyTuple_GetSlice(PyObject *t, int i, int j);
int       PyTuple_Check(PyObject *);
</PRE></DIV>
<P><B>Python Dictionary Functions</B> </P>
<DIV class=code><PRE>write me
</PRE></DIV>
<P><B>Python File Conversion Functions</B> </P>
<DIV class=code><PRE>PyObject *PyFile_FromFile(FILE *f);
FILE     *PyFile_AsFile(PyObject *);
int       PyFile_Check(PyObject *);
</PRE></DIV>
<P><B>Abstract Object Interface</B> </P>
<DIV class=code><PRE>write me
</PRE></DIV>
<H2><A name=Python_nn58></A>29.9 Typemap Examples</H2>
<P>This section includes a few examples of typemaps. For more examples, you 
might look at the files "<TT>python.swg</TT>" and "<TT>typemaps.i</TT>" in the 
SWIG library. </P>
<H3><A name=Python_nn59></A>29.9.1 Converting Python list to a char ** </H3>
<P>A common problem in many C programs is the processing of command line 
arguments, which are usually passed in an array of NULL terminated strings. The 
following SWIG interface file allows a Python list object to be used as a 
<TT>char **</TT> object. </P>
<DIV class=code><PRE>%module argv

// This tells SWIG to treat char ** as a special case
%typemap(in) char ** {
  /* Check if is a list */
  if (PyList_Check($input)) {
    int size = PyList_Size($input);
    int i = 0;
    $1 = (char **) malloc((size+1)*sizeof(char *));
    for (i = 0; i &lt; size; i++) {
      PyObject *o = PyList_GetItem($input,i);
      if (PyString_Check(o))
	$1[i] = PyString_AsString(PyList_GetItem($input,i));
      else {
	PyErr_SetString(PyExc_TypeError,"list must contain strings");
	free($1);
	return NULL;
      }
    }
    $1[i] = 0;
  } else {
    PyErr_SetString(PyExc_TypeError,"not a list");
    return NULL;
  }
}

// This cleans up the char ** array we malloc'd before the function call
%typemap(freearg) char ** {
  free((char *) $1);
}

// Now a test function
%inline %{
int print_args(char **argv) {
    int i = 0;
    while (argv[i]) {
         printf("argv[%d] = %s\n", i,argv[i]);
         i++;
    }
    return i;
}
%}

</PRE></DIV>
<P>When this module is compiled, the wrapped C function now operates as follows 
: </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; from argv import *
&gt;&gt;&gt; print_args(["Dave","Mike","Mary","Jane","John"])
argv[0] = Dave
argv[1] = Mike
argv[2] = Mary
argv[3] = Jane
argv[4] = John
5
</PRE></DIV>
<P>In the example, two different typemaps are used. The "in" typemap is used to 
receive an input argument and convert it to a C array. Since dynamic memory 
allocation is used to allocate memory for the array, the "freearg" typemap is 
used to later release this memory after the execution of the C function. </P>
<H3><A name=Python_nn60></A>29.9.2 Expanding a Python object into multiple 
arguments</H3>
<P>Suppose that you had a collection of C functions with arguments such as the 
following: </P>
<DIV class=code><PRE>int foo(int argc, char **argv);
</PRE></DIV>
<P>In the previous example, a typemap was written to pass a Python list as the 
<TT>char **argv</TT>. This allows the function to be used from Python as 
follows: </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; foo(4, ["foo","bar","spam","1"])
</PRE></DIV>
<P>Although this works, it's a little awkward to specify the argument count. To 
fix this, a multi-argument typemap can be defined. This is not very 
difficult--you only have to make slight modifications to the previous example: 
</P>
<DIV class=code><PRE>%typemap(in) (int argc, char **argv) {
  /* Check if is a list */
  if (PyList_Check($input)) {
    int i;
    $1 = PyList_Size($input);
    $2 = (char **) malloc(($1+1)*sizeof(char *));
    for (i = 0; i &lt; $1; i++) {
      PyObject *o = PyList_GetItem($input,i);
      if (PyString_Check(o))
	$2[i] = PyString_AsString(PyList_GetItem($input,i));
      else {
	PyErr_SetString(PyExc_TypeError,"list must contain strings");
	free($2);
	return NULL;
      }
    }
    $2[i] = 0;
  } else {
    PyErr_SetString(PyExc_TypeError,"not a list");
    return NULL;
  }
}

%typemap(freearg) (int argc, char **argv) {
  free((char *) $2);
}
</PRE></DIV>
<P>When writing a multiple-argument typemap, each of the types is referenced by 
a variable such as <TT>$1</TT> or <TT>$2</TT>. The typemap code simply fills in 
the appropriate values from the supplied Python object. </P>
<P>With the above typemap in place, you will find it no longer necessary to 
supply the argument count. This is automatically set by the typemap code. For 
example: </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; foo(["foo","bar","spam","1"])
</PRE></DIV>
<H3><A name=Python_nn61></A>29.9.3 Using typemaps to return arguments</H3>
<P>A common problem in some C programs is that values may be returned in 
arguments rather than in the return value of a function. For example: </P>
<DIV class=code><PRE>/* Returns a status value and two values in out1 and out2 */
int spam(double a, double b, double *out1, double *out2) {
	... Do a bunch of stuff ...
	*out1 = result1;
	*out2 = result2;
	return status;
};

</PRE></DIV>
<P>A typemap can be used to handle this case as follows : </P>
<DIV class=code><PRE>%module outarg

// This tells SWIG to treat an double * argument with name 'OutValue' as
// an output value.  We'll append the value to the current result which 
// is guaranteed to be a List object by SWIG.

%typemap(argout) double *OutValue {
    PyObject *o, *o2, *o3;
    o = PyFloat_FromDouble(*$1);
    if ((!$result) || ($result == Py_None)) {
        $result = o;
    } else {
        if (!PyTuple_Check($result)) {
            PyObject *o2 = $result;
            $result = PyTuple_New(1);
            PyTuple_SetItem(target,0,o2);
        }
        o3 = PyTuple_New(1);
        PyTuple_SetItem(o3,0,o);
        o2 = $result;
        $result = PySequence_Concat(o2,o3);
        Py_DECREF(o2);
        Py_DECREF(o3);
    }
}

int spam(double a, double b, double *OutValue, double *OutValue);

</PRE></DIV>
<P>The typemap works as follows. First, a check is made to see if any previous 
result exists. If so, it is turned into a tuple and the new output value is 
concatenated to it. Otherwise, the result is returned normally. For the sample 
function <TT>spam()</TT>, there are three output values--meaning that the 
function will return a 3-tuple of the results. </P>
<P>As written, the function must accept 4 arguments as input values, last two 
being pointers to doubles. If these arguments are only used to hold output 
values (and have no meaningful input value), an additional typemap can be 
written. For example: </P>
<DIV class=code><PRE>%typemap(in,numinputs=0) double *OutValue(double temp) {
    $1 = &amp;temp;
}

</PRE></DIV>
<P>By specifying numinputs=0, the input value is ignored. However, since the 
argument still has to be set to some meaningful value before calling C, it is 
set to point to a local variable <TT>temp</TT>. When the function stores its 
output value, it will simply be placed in this local variable. As a result, the 
function can now be used as follows: </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; a = spam(4,5)
&gt;&gt;&gt; print a
(0, 2.45, 5.0)
&gt;&gt;&gt; x,y,z = spam(4,5)
&gt;&gt;&gt;
</PRE></DIV>
<H3><A name=Python_nn62></A>29.9.4 Mapping Python tuples into small arrays</H3>
<P>In some applications, it is sometimes desirable to pass small arrays of 
numbers as arguments. For example : </P>
<DIV class=code><PRE>extern void set_direction(double a[4]);       // Set direction vector
</PRE></DIV>
<P>This too, can be handled used typemaps as follows : </P>
<DIV class=code><PRE>// Grab a 4 element array as a Python 4-tuple
%typemap(in) double[4](double temp[4]) {   // temp[4] becomes a local variable
  int i;
  if (PyTuple_Check($input)) {
    if (!PyArg_ParseTuple($input,"dddd",temp,temp+1,temp+2,temp+3)) {
      PyErr_SetString(PyExc_TypeError,"tuple must have 4 elements");
      return NULL;
    }
    $1 = &amp;temp[0];
  } else {
    PyErr_SetString(PyExc_TypeError,"expected a tuple.");
    return NULL;
  }
}

</PRE></DIV>
<P>This allows our <TT>set_direction</TT> function to be called from Python as 
follows : </P>
<DIV class=targetlang><PRE>&gt;&gt;&gt; set_direction((0.5,0.0,1.0,-0.25))
</PRE></DIV>
<P>Since our mapping copies the contents of a Python tuple into a C array, such 
an approach would not be recommended for huge arrays, but for small structures, 
this approach works fine. </P>
<H3><A name=Python_nn63></A>29.9.5 Mapping sequences to C arrays</H3>
<P>Suppose that you wanted to generalize the previous example to handle C arrays 
of different sizes. To do this, you might write a typemap as follows: </P>
<DIV class=code><PRE>// Map a Python sequence into any sized C double array
%typemap(in) double[ANY](double temp[$1_dim0]) {
  int i;
  if (!PySequence_Check($input)) {
      PyErr_SetString(PyExc_TypeError,"Expecting a sequence");
      return NULL;
  }
  if (PyObject_Length($input) != $1_dim0) {
      PyErr_SetString(PyExc_ValueError,"Expecting a sequence with $1_dim0 elements");
      return NULL;
  }
  for (i =0; i &lt; $1_dim0; i++) {
      PyObject *o = PySequence_GetItem($input,i);
      if (!PyFloat_Check(o)) {
         Py_XDECREF(o);
         PyErr_SetString(PyExc_ValueError,"Expecting a sequence of floats");
         return NULL;
      }
      temp[i] = PyFloat_AsDouble(o);
      Py_DECREF(o);
  }
  $1 = &amp;temp[0];
}
</PRE></DIV>
<P>In this case, the variable <TT>$1_dim0</TT> is expanded to match the array 
dimensions actually used in the C code. This allows the typemap to be applied to 
types such as: </P>
<DIV class=code><PRE>void foo(double x[10]);
void bar(double a[4], double b[8]);
</PRE></DIV>
<P>Since the above typemap code gets inserted into every wrapper function where 
used, it might make sense to use a helper function instead. This will greatly 
reduce the amount of wrapper code. For example: </P>
<DIV class=code><PRE>%{
static int convert_darray(PyObject *input, double *ptr, int size) {
  int i;
  if (!PySequence_Check(input)) {
      PyErr_SetString(PyExc_TypeError,"Expecting a sequence");
      return 0;
  }
  if (PyObject_Length(input) != size) {
      PyErr_SetString(PyExc_ValueError,"Sequence size mismatch");
      return 0;
  }
  for (i =0; i &lt; size; i++) {
      PyObject *o = PySequence_GetItem(input,i);
      if (!PyFloat_Check(o)) {
         Py_XDECREF(o);
         PyErr_SetString(PyExc_ValueError,"Expecting a sequence of floats");
         return 0;
      }
      ptr[i] = PyFloat_AsDouble(o);
      Py_DECREF(o);
  }
  return 1;
}
%}

%typemap(in) double [ANY](double temp[$1_dim0]) {
   if (!convert_darray($input,temp,$1_dim0))) {
      return NULL;
   }
   $1 = &amp;temp[0];
}
</PRE></DIV>
<H3><A name=Python_nn64></A>29.9.6 Pointer handling</H3>
<P>Occasionally, it might be necessary to convert pointer values that have been 
stored using the SWIG typed-pointer representation. Since there are several ways 
in which pointers can be represented, the following two functions are used to 
safely perform this conversion: </P>
<P><TT>int SWIG_ConvertPtr(PyObject *obj, void **ptr, swig_type_info *ty, int 
flags)</TT> </P>
<DIV class=indent>Converts a Python object <TT>obj</TT> to a C pointer. The 
result of the conversion is placed into the pointer located at <TT>ptr</TT>. 
<TT>ty</TT> is a SWIG type descriptor structure. <TT>flags</TT> is used to 
handle error checking and other aspects of conversion. It is the bitwise-or of 
several flag values including <TT>SWIG_POINTER_EXCEPTION</TT> and 
<TT>SWIG_POINTER_DISOWN</TT>. The first flag makes the function raise an 
exception on type error. The second flag additionally steals ownership of an 
object. Returns 0 on success and -1 on error. </DIV>
<P><TT>PyObject *SWIG_NewPointerObj(void *ptr, swig_type_info *ty, int own)</TT> 
</P>
<DIV class=indent>Creates a new Python pointer object. <TT>ptr</TT> is the 
pointer to convert, <TT>ty</TT> is the SWIG type descriptor structure that 
describes the type, and <TT>own</TT> is a flag that indicates whether or not 
Python should take ownership of the pointer. </DIV>
<P>Both of these functions require the use of a special SWIG type-descriptor 
structure. This structure contains information about the mangled name of the 
datatype, type-equivalence information, as well as information about converting 
pointer values under C++ inheritance. For a type of <TT>Foo *</TT>, the type 
descriptor structure is usually accessed as follows: </P>
<DIV class=code><PRE>Foo *f;
if (SWIG_ConvertPtr($input, (void **) &amp;f, SWIGTYPE_p_Foo, SWIG_POINTER_EXCEPTION) == -1)
  return NULL;

PyObject *obj;
obj = SWIG_NewPointerObj(f, SWIGTYPE_p_Foo, 0);
</PRE></DIV>
<P>In a typemap, the type descriptor should always be accessed using the special 
typemap variable <TT>$1_descriptor</TT>. For example: </P>
<DIV class=code><PRE>%typemap(in) Foo * {
if ((SWIG_ConvertPtr($input,(void **) &amp;$1, $1_descriptor,SWIG_POINTER_EXCEPTION)) == -1)
  return NULL;
}
</PRE></DIV>
<P>If necessary, the descriptor for any type can be obtained using the 
<TT>$descriptor()</TT> macro in a typemap. For example: </P>
<DIV class=code><PRE>%typemap(in) Foo * {
if ((SWIG_ConvertPtr($input,(void **) &amp;$1, $descriptor(Foo *), 
                                               SWIG_POINTER_EXCEPTION)) == -1)
  return NULL;
}
</PRE></DIV>
<P>Although the pointer handling functions are primarily intended for 
manipulating low-level pointers, both functions are fully aware of Python proxy 
classes. Specifically, <TT>SWIG_ConvertPtr()</TT> will retrieve a pointer from 
any object that has a <TT>this</TT> attribute. In addition, 
<TT>SWIG_NewPointerObj()</TT> can automatically generate a proxy class object 
(if applicable). </P>
<H2><A name=Python_nn65></A>29.10 Docstring Features</H2>
<P>Using docstrings in Python code is becoming more and more important and more 
tools are coming on the scene that take advantage of them, everything from 
full-blown documentaiton generators to class browsers and popup call-tips in 
Python-aware IDEs. Given the way that SWIG generates the proxy code by default, 
your users will normally get something like <TT>"function_name(*args)"</TT> in 
the popup calltip of their IDE which is next to useless when the real function 
prototype might be something like this: </P>
<DIV class=code><PRE>bool function_name(int x, int y, Foo* foo=NULL, Bar* bar=NULL);
</PRE></DIV>
<P>The features described in this section make it easy for you to add docstrings 
to your modules, functions and methods that can then be used by the various 
tools out there to make the programming experience of your users much simpler. 
</P>
<H3><A name=Python_nn66></A>29.10.1 Module docstring</H3>
<P>Python allows a docstring at the begining of the <TT>.py</TT> file before any 
other statements, and it is typically used to give a general description of the 
entire module. SWIG supports this by setting an option of the <TT>%module</TT> 
directive. For example: </P>
<DIV class=code><PRE>%module(docstring="This is the example module's docstring") example
</PRE></DIV>
<P>When you have more than just a line or so then you can retain the easy 
readability of the <TT>%module</TT> directive by using a macro. For example: 
</P>
<DIV class=code><PRE>%define DOCSTRING
"The `XmlResource` class allows program resources defining menus, 
layout of controls on a panel, etc. to be loaded from an XML file."
%enddef

%module(docstring=DOCSTRING) xrc
</PRE></DIV>
<H3><A name=Python_nn67></A>29.10.2 %feature("autodoc")</H3>
<P>As alluded to above SWIG will generate all the function and method proxy 
wrappers with just "*args" (or "*args, **kwargs" if the -keyword option is used) 
for a parameter list and will then sort out the individual parameters in the C 
wrapper code. This is nice and simple for the wrapper code, but makes it 
difficult to be programmer and tool friendly as anyone looking at the 
<TT>.py</TT> file will not be able to find out anything about the parameters 
that the fuctions accept. </P>
<P>But since SWIG does know everything about the fucntion it is possible to 
generate a docstring containing the parameter types, names and default values. 
Since many of the doctring tools are adopting a standard of recognizing if the 
first thing in the docstring is a function prototype then using that instead of 
what they found from introspeciton, then life is good once more. 
<P>SWIG's Python module provides support for the "autodoc" feature, which when 
attached to a node in the parse tree will cause a docstring to be generated that 
includes the name of the funciton, parameter names, default values if any, and 
return type if any. There are also three options for autodoc controlled by the 
value given to the feature, described below. 
<H4><A name=Python_nn68></A>29.10.2.1 %feature("autodoc", "0")</H4>
<P>When the "0" option is given then the types of the parameters will 
<EM>not</EM> be included in the autodoc string. For example, given this function 
prototype: </P>
<DIV class=code><PRE>%feature("autodoc", "0");
bool function_name(int x, int y, Foo* foo=NULL, Bar* bar=NULL);
</PRE></DIV>
<P>Then Python code like this will be generated: </P>
<DIV class=targetlang><PRE>def function_name(*args, **kwargs):
    """function_name(x, y, foo=None, bar=None) -&gt; bool"""
    ...
</PRE></DIV>
<H4><A name=Python_nn69></A>29.10.2.2 %feature("autodoc", "1")</H4>
<P>When the "1" option is used then the parameter types <EM>will</EM> be used in 
the autodoc string. In addition, an atempt is made to simplify the type name 
such that it makes more sense to the Python user. Pointer, reference and const 
info is removed, <TT>%rename</TT>'s are evaluated, etc. (This is not always 
successful, but works most of the time. See the next section for what to do when 
it doesn't.) Given the example above, then turning on the parameter types with 
the "1" option will result in Python code like this: </P>
<DIV class=targetlang><PRE>def function_name(*args, **kwargs):
    """function_name(int x, int y, Foo foo=None, Bar bar=None) -&gt; bool"""
    ...
</PRE></DIV>
<H4><A name=Python_nn70></A>29.10.2.3 %feature("autodoc", "docstring")</H4>
<P>Finally, there are times when the automatically generated autodoc string will 
make no sense for a Python programmer, particularly when a typemap is involved. 
So if you give an explicit value for the autodoc feature then that string will 
be used in place of the automatically generated string. For example: </P>
<DIV class=code><PRE>%feature("autodoc", "GetPosition() -&gt; (x, y)") GetPosition;
void GetPosition(int* OUTPUT, int* OUTPUT);
</PRE></DIV>
<H3><A name=Python_nn71></A>29.10.3 %feature("docstring")</H3>
<P>In addition to the autodoc strings described above, you can also attach any 
arbitrary descriptive text to a node in the parse tree with the "docstring" 
feature. When the proxy module is generated then any docstring associated with 
classes, function or methods are output. If an item already has an autodoc 
string then it is combined with the docstring and they are output together. If 
the docstring is all on a single line then it is output like this:: </P>
<DIV class=targetlang><PRE>"""This is the docstring"""
</PRE></DIV>
<P>Otherwise, to aid readability it is output like this: </P>
<DIV class=targetlang><PRE>"""
This is a multi-line docstring
with more than one line.
"""
</PRE></DIV>
<H2><A name=Python_nn72></A>29.11 Python Packages</H2>
<P>Using the <TT>package</TT> option of the <TT>%module</TT> directive allows 
you to specify what Python package that the module will be living in when 
installed. </P>
<DIV class=code><PRE>%module(package="wx") xrc
</PRE></DIV>
<P>This is useful when the <TT>.i</TT> file is <TT>%import</TT>ed by another 
<TT>.i</TT> file. By default SWIG will assume that the importer is able to find 
the importee with just the module name, but if they live in separate Python 
packages then that won't work. However if the importee specifies what its 
package is with the <TT>%module</TT> option then the Python code generated for 
the importer will use that package name when importing the other module and also 
in base class declarations, etc. if the pacakge name is different than its own. 
</P><!--  LocalWords:  polymorphism Typemaps STL typemap typemaps Docstring autodoc
 --><!--  LocalWords:  docstring SWIG's cxx py GCC linux DLL gcc fPIC Wiki Xlinker
 --><!--  LocalWords:  examplemodule DHAVE CONFIG lpython lm ldl mypython lsocket
 --><!--  LocalWords:  lnsl lpthread distutils enums namespaces
 --></BODY></HTML>
